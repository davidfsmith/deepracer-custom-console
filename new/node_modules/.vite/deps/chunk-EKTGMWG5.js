import {
  LinkDefaultVariantContext,
  Portal,
  browserScrollbarSize,
  focus_lock_default,
  internal_default as internal_default3,
  radio_button_default,
  useModalContext
} from "./chunk-U74SLQDB.js";
import {
  CollectionLabelContext,
  StickyHeaderContext,
  calculateScroll,
  getFirstScrollableParent,
  getOverflowParents,
  scrollElementIntoView,
  scrollRectangleIntoView,
  styles_css_default,
  useAppLayoutContext,
  useMobile,
  useStickyHeader
} from "./chunk-ATFH3LQM.js";
import {
  useDebounceCallback
} from "./chunk-XYTAOB5V.js";
import {
  getAllFocusables
} from "./chunk-OD24TJP5.js";
import {
  InternalSpaceBetween
} from "./chunk-PM64MP4D.js";
import {
  InternalFormField,
  isDevelopment,
  useContainerBreakpoints,
  useContainerQuery
} from "./chunk-2STP5MNB.js";
import {
  joinStrings
} from "./chunk-42BEG66H.js";
import {
  useInternalI18n
} from "./chunk-ODZSV7SK.js";
import {
  InternalButton,
  InternalSpinner,
  SingleTabStopNavigationContext,
  internal_default as internal_default2,
  usePerformanceMarks,
  useSingleTabStopNavigation
} from "./chunk-7I72EAPF.js";
import {
  fireCancelableEvent,
  fireNonCancelableEvent
} from "./chunk-T3BYYNEM.js";
import {
  FunnelContext,
  FunnelMetrics,
  FunnelStepContext,
  FunnelSubStepContext,
  ScreenreaderOnly,
  live_region_default,
  nodeBelongs,
  useFunnel,
  useFunnelStep,
  useFunnelSubStep
} from "./chunk-TVECJW2U.js";
import {
  DATA_ATTR_FUNNEL_STEP,
  findUpUntil as findUpUntil2,
  getContainingBlock,
  getFunnelNameSelector,
  getNameFromSelector,
  getSubStepAllSelector,
  getSubStepNameSelector,
  getSubStepSelector,
  supportsStickyPosition,
  useUniqueId
} from "./chunk-MKRUABPM.js";
import {
  internal_default,
  useMergeRefs
} from "./chunk-YL662TD3.js";
import {
  KeyCode,
  PACKAGE_VERSION,
  ResizeObserver,
  __awaiter,
  __rest,
  applyDisplayName,
  clsx_m_default,
  createSingletonHandler,
  findUpUntil,
  getBaseProps,
  nodeContains,
  useBaseComponent,
  useCurrentMode,
  useDensityMode,
  useResizeObserver,
  useStableCallback,
  useVisualRefresh,
  warnOnce
} from "./chunk-3NFHZQPK.js";
import {
  require_react_dom
} from "./chunk-HKXRFMQU.js";
import {
  require_react
} from "./chunk-WHMHD7EJ.js";
import {
  __toESM
} from "./chunk-G3PMV62Z.js";

// node_modules/@cloudscape-design/components/table/index.js
var import_react42 = __toESM(require_react());

// node_modules/@cloudscape-design/components/table/internal.js
var import_react40 = __toESM(require_react());

// node_modules/@cloudscape-design/components/internal/components/visual-context/index.js
var import_react = __toESM(require_react());
var contextMatch = /awsui-context-([\w-]+)/;
function useVisualContext(elementRef) {
  const [value, setValue] = (0, import_react.useState)("");
  (0, import_react.useLayoutEffect)(() => {
    var _a;
    if (elementRef.current) {
      const contextParent = findUpUntil2(elementRef.current, (node) => !!node.className.match(contextMatch));
      setValue((_a = contextParent === null || contextParent === void 0 ? void 0 : contextParent.className.match(contextMatch)[1]) !== null && _a !== void 0 ? _a : "");
    }
  }, [elementRef]);
  return value;
}
function getVisualContextClassname(contextName) {
  return `awsui-context-${contextName}`;
}
function VisualContext({ contextName, className, children }) {
  return import_react.default.createElement("div", { className: clsx_m_default(getVisualContextClassname(contextName), className) }, children);
}

// node_modules/@cloudscape-design/components/container/internal.js
var import_react5 = __toESM(require_react());

// node_modules/@cloudscape-design/components/internal/utils/global-flags.js
var awsuiGlobalFlagsSymbol = Symbol.for("awsui-global-flags");
var getTopWindow = () => {
  return window.top;
};
function getGlobal() {
  return typeof window !== "undefined" ? window : globalThis;
}
function readFlag(window2, flagName) {
  var _a;
  const holder = window2;
  return (_a = holder === null || holder === void 0 ? void 0 : holder[awsuiGlobalFlagsSymbol]) === null || _a === void 0 ? void 0 : _a[flagName];
}
var getGlobalFlag = (flagName) => {
  try {
    const ownFlag = readFlag(getGlobal(), flagName);
    if (ownFlag !== void 0) {
      return ownFlag;
    }
    return readFlag(getTopWindow(), flagName);
  } catch (e) {
    return void 0;
  }
};

// node_modules/@cloudscape-design/components/internal/utils/content-header-utils.js
var shouldRemoveHighContrastHeader = () => !!getGlobalFlag("removeHighContrastHeader");
var getContentHeaderClassName = () => shouldRemoveHighContrastHeader() ? "" : "awsui-context-content-header";

// node_modules/@cloudscape-design/components/internal/hooks/use-dynamic-overlap/index.js
var import_react3 = __toESM(require_react());

// node_modules/@cloudscape-design/components/internal/context/dynamic-overlap-context.js
var import_react2 = __toESM(require_react());
var DynamicOverlapContext = (0, import_react2.createContext)(() => {
});

// node_modules/@cloudscape-design/components/internal/hooks/use-dynamic-overlap/index.js
var import_react4 = __toESM(require_react());
function useDynamicOverlap(props) {
  var _a;
  const disabled = (_a = props === null || props === void 0 ? void 0 : props.disabled) !== null && _a !== void 0 ? _a : false;
  const setDynamicOverlapHeight = (0, import_react3.useContext)(DynamicOverlapContext);
  const overlapElementRef = (0, import_react4.useRef)(null);
  const getElement = (0, import_react4.useCallback)(() => overlapElementRef.current, [overlapElementRef]);
  const updateState = (0, import_react4.useCallback)((entry) => {
    if (!disabled) {
      setDynamicOverlapHeight(entry.contentBoxHeight);
    }
  }, [disabled, setDynamicOverlapHeight]);
  useResizeObserver(getElement, updateState);
  (0, import_react3.useLayoutEffect)(function handleDynamicOverlapHeight() {
    return () => {
      if (!disabled) {
        setDynamicOverlapHeight(0);
      }
    };
  }, [disabled, setDynamicOverlapHeight]);
  return overlapElementRef;
}

// node_modules/@cloudscape-design/components/container/styles.css.js
import "/home/a171157/personal-repos/deep-racer/community-contributions/deepracer-custom-console/new/node_modules/@cloudscape-design/components/container/styles.scoped.css";
var styles_css_default2 = {
  "root": "awsui_root_14iqq_v4tpg_103",
  "fit-height": "awsui_fit-height_14iqq_v4tpg_139",
  "with-side-media": "awsui_with-side-media_14iqq_v4tpg_144",
  "variant-default": "awsui_variant-default_14iqq_v4tpg_147",
  "variant-stacked": "awsui_variant-stacked_14iqq_v4tpg_147",
  "refresh": "awsui_refresh_14iqq_v4tpg_155",
  "sticky-enabled": "awsui_sticky-enabled_14iqq_v4tpg_205",
  "with-top-media": "awsui_with-top-media_14iqq_v4tpg_217",
  "content-wrapper": "awsui_content-wrapper_14iqq_v4tpg_222",
  "content-wrapper-fit-height": "awsui_content-wrapper-fit-height_14iqq_v4tpg_227",
  "media": "awsui_media_14iqq_v4tpg_234",
  "media-top": "awsui_media-top_14iqq_v4tpg_252",
  "media-side": "awsui_media-side_14iqq_v4tpg_257",
  "header": "awsui_header_14iqq_v4tpg_263",
  "header-with-media": "awsui_header-with-media_14iqq_v4tpg_268",
  "header-sticky-disabled": "awsui_header-sticky-disabled_14iqq_v4tpg_274",
  "header-sticky-enabled": "awsui_header-sticky-enabled_14iqq_v4tpg_278",
  "header-stuck": "awsui_header-stuck_14iqq_v4tpg_284",
  "header-variant-cards": "awsui_header-variant-cards_14iqq_v4tpg_294",
  "header-dynamic-height": "awsui_header-dynamic-height_14iqq_v4tpg_297",
  "with-paddings": "awsui_with-paddings_14iqq_v4tpg_303",
  "with-hidden-content": "awsui_with-hidden-content_14iqq_v4tpg_312",
  "header-variant-full-page": "awsui_header-variant-full-page_14iqq_v4tpg_370",
  "remove-high-contrast-header": "awsui_remove-high-contrast-header_14iqq_v4tpg_390",
  "dark-header": "awsui_dark-header_14iqq_v4tpg_399",
  "content": "awsui_content_14iqq_v4tpg_222",
  "content-fit-height": "awsui_content-fit-height_14iqq_v4tpg_407",
  "content-with-media": "awsui_content-with-media_14iqq_v4tpg_417",
  "footer": "awsui_footer_14iqq_v4tpg_421",
  "with-divider": "awsui_with-divider_14iqq_v4tpg_425"
};

// node_modules/@cloudscape-design/components/container/internal.js
function InternalContainerAsSubstep(props) {
  const { subStepRef, funnelSubStepProps } = useFunnelSubStep();
  const modalContext = useModalContext();
  return import_react5.default.createElement(InternalContainer, Object.assign({}, props, { __subStepRef: (modalContext === null || modalContext === void 0 ? void 0 : modalContext.isInModal) ? { current: null } : subStepRef, __funnelSubStepProps: (modalContext === null || modalContext === void 0 ? void 0 : modalContext.isInModal) ? {} : funnelSubStepProps }));
}
function InternalContainer(_a) {
  var _b;
  var { header, footer, children, variant = "default", disableHeaderPaddings = false, disableContentPaddings = false, fitHeight, media, __stickyOffset, __mobileStickyOffset, __stickyHeader = false, __internalRootRef = null, __disableFooterDivider = false, __disableFooterPaddings = false, __hiddenContent = false, __headerRef, __darkHeader = false, __disableStickyMobile = true, __funnelSubStepProps, __subStepRef } = _a, restProps = __rest(_a, ["header", "footer", "children", "variant", "disableHeaderPaddings", "disableContentPaddings", "fitHeight", "media", "__stickyOffset", "__mobileStickyOffset", "__stickyHeader", "__internalRootRef", "__disableFooterDivider", "__disableFooterPaddings", "__hiddenContent", "__headerRef", "__darkHeader", "__disableStickyMobile", "__funnelSubStepProps", "__subStepRef"]);
  const isMobile = useMobile();
  const baseProps = getBaseProps(restProps);
  const rootRef = (0, import_react5.useRef)(null);
  const headerRef = (0, import_react5.useRef)(null);
  const { isSticky, isStuck, stickyStyles } = useStickyHeader(rootRef, headerRef, __stickyHeader, __stickyOffset, __mobileStickyOffset, __disableStickyMobile);
  const contentId = useUniqueId();
  const { setHasStickyBackground } = useAppLayoutContext();
  const isRefresh = useVisualRefresh();
  const hasDynamicHeight = isRefresh && variant === "full-page";
  const overlapElement = useDynamicOverlap({ disabled: !hasDynamicHeight || !__darkHeader });
  const mergedRef = useMergeRefs(rootRef, __internalRootRef);
  const headerMergedRef = useMergeRefs(headerRef, overlapElement, __headerRef);
  (0, import_react5.useEffect)(() => {
    const shouldUpdateStickyBackground = isSticky && variant === "full-page" && setHasStickyBackground;
    if (shouldUpdateStickyBackground) {
      setHasStickyBackground(true);
    }
    return () => {
      if (shouldUpdateStickyBackground) {
        setHasStickyBackground(false);
      }
    };
  }, [isSticky, setHasStickyBackground, variant]);
  const shouldHaveStickyStyles = isSticky && !isMobile;
  const hasMedia = !!(media === null || media === void 0 ? void 0 : media.content);
  const mediaPosition = (_b = media === null || media === void 0 ? void 0 : media.position) !== null && _b !== void 0 ? _b : "top";
  return import_react5.default.createElement(
    "div",
    Object.assign({}, baseProps, __funnelSubStepProps, { className: clsx_m_default(baseProps.className, styles_css_default2.root, styles_css_default2[`variant-${variant}`], fitHeight && styles_css_default2["fit-height"], hasMedia && (mediaPosition === "side" ? styles_css_default2["with-side-media"] : styles_css_default2["with-top-media"]), shouldHaveStickyStyles && [styles_css_default2["sticky-enabled"]], isRefresh && styles_css_default2.refresh), ref: mergedRef }),
    hasMedia && import_react5.default.createElement("div", { className: clsx_m_default(styles_css_default2[`media-${mediaPosition === "side" ? "side" : "top"}`], styles_css_default2.media), style: mediaPosition === "top" ? { height: (media === null || media === void 0 ? void 0 : media.height) || "" } : { width: (media === null || media === void 0 ? void 0 : media.width) || "" } }, media.content),
    import_react5.default.createElement(
      "div",
      { id: contentId, ref: __subStepRef, className: clsx_m_default(styles_css_default2["content-wrapper"], fitHeight && styles_css_default2["content-wrapper-fit-height"]) },
      header && import_react5.default.createElement(
        StickyHeaderContext.Provider,
        { value: { isStuck } },
        import_react5.default.createElement("div", Object.assign({ className: clsx_m_default(isRefresh && styles_css_default2.refresh, styles_css_default2.header, styles_css_default2[`header-variant-${variant}`], shouldRemoveHighContrastHeader() && styles_css_default2["remove-high-contrast-header"], {
          [styles_css_default2["header-sticky-disabled"]]: __stickyHeader && !isSticky,
          [styles_css_default2["header-sticky-enabled"]]: isSticky,
          [styles_css_default2["header-dynamic-height"]]: hasDynamicHeight,
          [styles_css_default2["header-stuck"]]: isStuck,
          [styles_css_default2["with-paddings"]]: !disableHeaderPaddings,
          [styles_css_default2["with-hidden-content"]]: !children || __hiddenContent,
          [styles_css_default2["header-with-media"]]: hasMedia
        }) }, stickyStyles, { ref: headerMergedRef }), __darkHeader ? import_react5.default.createElement("div", { className: clsx_m_default(styles_css_default2["dark-header"], getContentHeaderClassName()) }, header) : header)
      ),
      import_react5.default.createElement("div", { className: clsx_m_default(styles_css_default2.content, fitHeight && styles_css_default2["content-fit-height"], shouldRemoveHighContrastHeader() && styles_css_default2["remove-high-contrast-header"], {
        [styles_css_default2["with-paddings"]]: !disableContentPaddings
      }) }, children),
      footer && import_react5.default.createElement("div", { className: clsx_m_default(styles_css_default2.footer, {
        [styles_css_default2["with-divider"]]: !__disableFooterDivider,
        [styles_css_default2["with-paddings"]]: !__disableFooterPaddings
      }) }, footer)
    )
  );
}

// node_modules/@cloudscape-design/components/table/tools-header.js
var import_react6 = __toESM(require_react());

// node_modules/@cloudscape-design/components/table/styles.css.js
import "/home/a171157/personal-repos/deep-racer/community-contributions/deepracer-custom-console/new/node_modules/@cloudscape-design/components/table/styles.scoped.css";
var styles_css_default3 = {
  "root": "awsui_root_wih1l_qzfuf_103",
  "tools": "awsui_tools_wih1l_qzfuf_114",
  "tools-filtering": "awsui_tools-filtering_wih1l_qzfuf_122",
  "tools-align-right": "awsui_tools-align-right_wih1l_qzfuf_136",
  "tools-pagination": "awsui_tools-pagination_wih1l_qzfuf_140",
  "tools-preferences": "awsui_tools-preferences_wih1l_qzfuf_140",
  "tools-small": "awsui_tools-small_wih1l_qzfuf_146",
  "table": "awsui_table_wih1l_qzfuf_152",
  "table-layout-fixed": "awsui_table-layout-fixed_wih1l_qzfuf_158",
  "wrapper": "awsui_wrapper_wih1l_qzfuf_162",
  "variant-stacked": "awsui_variant-stacked_wih1l_qzfuf_169",
  "wrapper-content-measure": "awsui_wrapper-content-measure_wih1l_qzfuf_169",
  "variant-container": "awsui_variant-container_wih1l_qzfuf_169",
  "has-footer": "awsui_has-footer_wih1l_qzfuf_172",
  "has-header": "awsui_has-header_wih1l_qzfuf_175",
  "cell-merged": "awsui_cell-merged_wih1l_qzfuf_192",
  "cell-merged-content": "awsui_cell-merged-content_wih1l_qzfuf_204",
  "empty": "awsui_empty_wih1l_qzfuf_222",
  "loading": "awsui_loading_wih1l_qzfuf_226",
  "selection-control": "awsui_selection-control_wih1l_qzfuf_235",
  "selection-control-header": "awsui_selection-control-header_wih1l_qzfuf_242",
  "dark-header": "awsui_dark-header_wih1l_qzfuf_252",
  "header-secondary": "awsui_header-secondary_wih1l_qzfuf_257",
  "table-has-header": "awsui_table-has-header_wih1l_qzfuf_275",
  "header-controls": "awsui_header-controls_wih1l_qzfuf_279",
  "variant-full-page": "awsui_variant-full-page_wih1l_qzfuf_282",
  "variant-embedded": "awsui_variant-embedded_wih1l_qzfuf_288",
  "variant-borderless": "awsui_variant-borderless_wih1l_qzfuf_288",
  "footer-wrapper": "awsui_footer-wrapper_wih1l_qzfuf_293",
  "footer": "awsui_footer_wih1l_qzfuf_293",
  "footer-with-pagination": "awsui_footer-with-pagination_wih1l_qzfuf_301",
  "footer-pagination": "awsui_footer-pagination_wih1l_qzfuf_309",
  "thead-active": "awsui_thead-active_wih1l_qzfuf_313",
  "row": "awsui_row_wih1l_qzfuf_314",
  "row-selected": "awsui_row-selected_wih1l_qzfuf_315"
};

// node_modules/@cloudscape-design/components/table/tools-header.js
function ToolsHeader({ header, filter, pagination, preferences }) {
  const [breakpoint, ref] = useContainerBreakpoints(["xs"]);
  const isHeaderString = typeof header === "string";
  const assignHeaderId = (0, import_react6.useContext)(CollectionLabelContext).assignId;
  const headingId = useUniqueId("heading");
  if (assignHeaderId !== void 0 && isHeaderString) {
    assignHeaderId(headingId);
  }
  const isSmall = breakpoint === "default";
  const hasTools = filter || pagination || preferences;
  return import_react6.default.createElement(
    import_react6.default.Fragment,
    null,
    isHeaderString ? import_react6.default.createElement("span", { id: headingId }, header) : header,
    hasTools && import_react6.default.createElement(
      "div",
      { ref, className: clsx_m_default(styles_css_default3.tools, isSmall && styles_css_default3["tools-small"]) },
      filter && import_react6.default.createElement("div", { className: styles_css_default3["tools-filtering"] }, filter),
      import_react6.default.createElement(
        "div",
        { className: styles_css_default3["tools-align-right"] },
        pagination && import_react6.default.createElement("div", { className: styles_css_default3["tools-pagination"] }, pagination),
        preferences && import_react6.default.createElement("div", { className: styles_css_default3["tools-preferences"] }, preferences)
      )
    )
  );
}

// node_modules/@cloudscape-design/components/table/thead.js
var import_react18 = __toESM(require_react());

// node_modules/@cloudscape-design/components/table/selection/selection-control.js
var import_react7 = __toESM(require_react());

// node_modules/@cloudscape-design/components/table/selection/styles.css.js
import "/home/a171157/personal-repos/deep-racer/community-contributions/deepracer-custom-console/new/node_modules/@cloudscape-design/components/table/selection/styles.scoped.css";
var styles_css_default4 = {
  "root": "awsui_root_1s55x_d36ci_99",
  "label": "awsui_label_1s55x_d36ci_103",
  "stud": "awsui_stud_1s55x_d36ci_117"
};

// node_modules/@cloudscape-design/components/table/selection/selection-control.js
function SelectionControl(_a) {
  var { selectionType, indeterminate = false, onShiftToggle, onFocusUp, onFocusDown, name, ariaLabel, focusedComponent } = _a, sharedProps = __rest(_a, ["selectionType", "indeterminate", "onShiftToggle", "onFocusUp", "onFocusDown", "name", "ariaLabel", "focusedComponent"]);
  const controlId = useUniqueId();
  const isMultiSelection = selectionType === "multi";
  const { navigationActive } = (0, import_react7.useContext)(SingleTabStopNavigationContext);
  const setShiftState = (event) => {
    if (isMultiSelection) {
      onShiftToggle && onShiftToggle(event.shiftKey);
    }
  };
  const onMouseDownHandler = (event) => {
    setShiftState(event);
    if (isMultiSelection) {
      event.preventDefault();
    }
  };
  const handleKeyDown = (event) => {
    setShiftState(event);
    if (isMultiSelection && !navigationActive) {
      if (event.keyCode === KeyCode.up) {
        event.preventDefault();
        onFocusUp && onFocusUp(event);
      }
      if (event.keyCode === KeyCode.down) {
        event.preventDefault();
        onFocusDown && onFocusDown(event);
      }
    }
  };
  const handleClick = (event) => {
    const target = event.currentTarget;
    const nativeInput = target.tagName === "INPUT" ? target : target.querySelector("input");
    nativeInput === null || nativeInput === void 0 ? void 0 : nativeInput.focus();
  };
  const selector = isMultiSelection ? import_react7.default.createElement(internal_default3, Object.assign({}, sharedProps, { showOutline: focusedComponent === "selection-control", controlId, "data-focus-id": "selection-control", indeterminate })) : import_react7.default.createElement(radio_button_default, Object.assign({}, sharedProps, { controlId, name, value: "", label: "" }));
  return import_react7.default.createElement(
    import_react7.default.Fragment,
    null,
    import_react7.default.createElement("label", { onKeyDown: handleKeyDown, onKeyUp: setShiftState, onMouseDown: onMouseDownHandler, onMouseUp: setShiftState, onClick: handleClick, htmlFor: controlId, className: clsx_m_default(styles_css_default4.label, styles_css_default4.root), "aria-label": ariaLabel, title: ariaLabel }, selector),
    import_react7.default.createElement("span", { className: clsx_m_default(styles_css_default4.stud), "aria-hidden": true }, "Â ")
  );
}

// node_modules/@cloudscape-design/components/table/utils.js
var applyTrackBy = (trackBy, item) => {
  if (typeof trackBy === "function") {
    return trackBy(item);
  }
  return item[trackBy];
};
var getItemKey = (trackBy, item, index) => {
  if (!trackBy) {
    return index;
  }
  return applyTrackBy(trackBy, item);
};
var getTrackableValue = (trackBy, item) => {
  if (!trackBy) {
    return item;
  }
  return applyTrackBy(trackBy, item);
};
var getColumnKey = (column, index) => {
  return column.id || index;
};
var toContainerVariant = (variant) => {
  const isDefaultVariant = !variant || variant === "container";
  return isDefaultVariant ? "default" : variant === "borderless" ? "embedded" : variant;
};
function checkSortingState(columnDefinitions, sortingComparator) {
  const matchedColumn = columnDefinitions.filter((column) => column.sortingComparator === sortingComparator)[0];
  if (!matchedColumn) {
    warnOnce("Table", "Currently active sorting comparator was not found in any columns. Make sure to provide the same comparator function instance on each render.");
  }
}
function getVisibleColumnDefinitions({ columnDisplay, visibleColumns, columnDefinitions }) {
  if (columnDisplay) {
    return getVisibleColumnDefinitionsFromColumnDisplay({ columnDisplay, columnDefinitions });
  } else if (visibleColumns) {
    return getVisibleColumnDefinitionsFromVisibleColumns({ visibleColumns, columnDefinitions });
  } else {
    return columnDefinitions;
  }
}
function getVisibleColumnDefinitionsFromColumnDisplay({ columnDisplay, columnDefinitions }) {
  const columnDefinitionsById = columnDefinitions.reduce((accumulator, item) => item.id === void 0 ? accumulator : Object.assign(Object.assign({}, accumulator), { [item.id]: item }), {});
  return columnDisplay.filter((item) => item.visible).map((item) => columnDefinitionsById[item.id]).filter(Boolean);
}
function getVisibleColumnDefinitionsFromVisibleColumns({ visibleColumns, columnDefinitions }) {
  const ids = new Set(visibleColumns);
  return columnDefinitions.filter(({ id }) => id !== void 0 && ids.has(id));
}
function getStickyClassNames(styles, props) {
  return {
    [styles["sticky-cell"]]: !!props,
    [styles["sticky-cell-pad-left"]]: !!(props === null || props === void 0 ? void 0 : props.padLeft),
    [styles["sticky-cell-last-left"]]: !!(props === null || props === void 0 ? void 0 : props.lastLeft),
    [styles["sticky-cell-last-right"]]: !!(props === null || props === void 0 ? void 0 : props.lastRight)
  };
}

// node_modules/@cloudscape-design/components/table/selection/utils.js
var SELECTION_ITEM = "selection-item";
var SELECTION_ROOT = "selection-root";
var ItemSet = class {
  constructor(trackBy, items) {
    this.map = /* @__PURE__ */ new Map();
    this.put = (item) => this.map.set.call(this.map, getTrackableValue(this.trackBy, item), item);
    this.has = (item) => this.map.has.call(this.map, getTrackableValue(this.trackBy, item));
    this.forEach = this.map.forEach.bind(this.map);
    this.trackBy = trackBy;
    items.forEach(this.put);
  }
};
var focusMarkers = {
  item: { ["data-" + SELECTION_ITEM]: "item" },
  all: { ["data-" + SELECTION_ITEM]: "all" },
  root: { ["data-" + SELECTION_ROOT]: "true" }
};

// node_modules/@cloudscape-design/components/table/selection/use-selection-focus-move.js
function useSelectionFocusMove(selectionType, totalItems) {
  if (selectionType !== "multi") {
    return {};
  }
  function moveFocus(sourceElement, fromIndex, direction) {
    let index = fromIndex;
    const rootContainer = findRootContainer(sourceElement);
    while (index >= -1 && index < totalItems) {
      index += direction;
      const control = findSelectionControlByIndex(rootContainer, index);
      if (control && !control.disabled) {
        control.focus();
        break;
      }
    }
  }
  const [moveFocusDown, moveFocusUp] = [1, -1].map((direction) => {
    return (event) => {
      const target = event.currentTarget;
      const itemNode = findUpUntil2(target, (node) => node.dataset.selectionItem === "item");
      const fromIndex = Array.prototype.indexOf.call(itemNode.parentElement.children, itemNode);
      moveFocus(target, fromIndex, direction);
    };
  });
  return {
    moveFocusDown,
    moveFocusUp,
    moveFocus
  };
}
function findSelectionControlByIndex(rootContainer, index) {
  if (index === -1) {
    return rootContainer.querySelector(`[data-${SELECTION_ITEM}="all"] .${styles_css_default4.root} input`);
  }
  return rootContainer.querySelectorAll(`[data-${SELECTION_ITEM}="item"] .${styles_css_default4.root} input`)[index];
}
function findRootContainer(element) {
  return findUpUntil2(element, (node) => node.dataset.selectionRoot === "true");
}

// node_modules/@cloudscape-design/components/table/selection/use-selection.js
var import_react8 = __toESM(require_react());
function useSelection({ items, selectedItems = [], selectionType, isItemDisabled = () => false, trackBy, onSelectionChange, ariaLabels, loading }) {
  const [shiftPressed, setShiftPressed] = (0, import_react8.useState)(false);
  const [lastClickedItem, setLastClickedItem] = (0, import_react8.useState)(null);
  const selectionName = useUniqueId();
  const finalSelectedItems = selectionType === "single" ? selectedItems.slice(0, 1) : selectedItems;
  const selectedSet = new ItemSet(trackBy, finalSelectedItems);
  const itemIndexesMap = /* @__PURE__ */ new Map();
  items.forEach((item, i) => itemIndexesMap.set(getTrackableValue(trackBy, item), i));
  const isItemSelected = selectedSet.has.bind(selectedSet);
  const getItemState = (item) => ({
    disabled: isItemDisabled(item),
    selected: isItemSelected(item)
  });
  const [allDisabled, allEnabledSelected] = selectionType ? items.reduce(([allDisabled2, allEnabledSelected2], item) => {
    const { disabled, selected } = getItemState(item);
    return [
      // all items are disabled (or none are present)
      allDisabled2 && disabled,
      // all enabled items are selected (or none are present)
      allEnabledSelected2 && (selected || disabled)
    ];
  }, [true, true]) : [true, true];
  const hasSelected = finalSelectedItems.length > 0;
  const handleToggleAll = () => {
    const requestedItems = new ItemSet(trackBy, items);
    const newSelectedItems = allEnabledSelected ? deselectItems(requestedItems) : selectItems(requestedItems);
    fireNonCancelableEvent(onSelectionChange, { selectedItems: newSelectedItems });
  };
  const getRequestedItems = (item) => {
    const requestedItems = new ItemSet(trackBy, [item]);
    let lastClickedItemIndex = lastClickedItem ? itemIndexesMap.get(getTrackableValue(trackBy, lastClickedItem)) : -1;
    if (lastClickedItemIndex === void 0) {
      lastClickedItemIndex = -1;
    }
    if (shiftPressed && lastClickedItemIndex !== -1) {
      const currentItemIndex = itemIndexesMap.get(getTrackableValue(trackBy, item));
      const start = Math.min(currentItemIndex, lastClickedItemIndex);
      const end = Math.max(currentItemIndex, lastClickedItemIndex);
      items.slice(start, end + 1).forEach((item2) => requestedItems.put(item2));
    }
    return requestedItems;
  };
  const deselectItems = (requestedItems) => {
    const newSelectedItems = [];
    selectedItems.forEach((selectedItem) => {
      const toUnselect = requestedItems.has(selectedItem);
      if (!toUnselect || isItemDisabled(selectedItem)) {
        newSelectedItems.push(selectedItem);
      }
    });
    return newSelectedItems;
  };
  const selectItems = (requestedItems) => {
    const newSelectedItems = [...selectedItems];
    requestedItems.forEach((newItem) => {
      const { selected, disabled } = getItemState(newItem);
      if (!selected && !disabled) {
        newSelectedItems.push(newItem);
      }
    });
    return newSelectedItems;
  };
  const handleToggleItem = (item) => () => {
    const { disabled, selected } = getItemState(item);
    if (disabled || selectionType === "single" && selected) {
      return;
    }
    if (selectionType === "single") {
      fireNonCancelableEvent(onSelectionChange, { selectedItems: [item] });
    } else {
      const requestedItems = getRequestedItems(item);
      const selectedItems2 = selected ? deselectItems(requestedItems) : selectItems(requestedItems);
      fireNonCancelableEvent(onSelectionChange, { selectedItems: selectedItems2 });
      setLastClickedItem(item);
    }
  };
  return {
    isItemSelected,
    getSelectAllProps: () => {
      var _a;
      if (!selectionType) {
        throw new Error("Invariant violation: calling selection props with missing selection type.");
      }
      return {
        name: selectionName,
        disabled: allDisabled || !!loading,
        selectionType,
        indeterminate: hasSelected && !allEnabledSelected,
        checked: hasSelected && allEnabledSelected,
        onChange: handleToggleAll,
        ariaLabel: joinStrings(ariaLabels === null || ariaLabels === void 0 ? void 0 : ariaLabels.selectionGroupLabel, (_a = ariaLabels === null || ariaLabels === void 0 ? void 0 : ariaLabels.allItemsSelectionLabel) === null || _a === void 0 ? void 0 : _a.call(ariaLabels, { selectedItems }))
      };
    },
    getItemSelectionProps: (item) => {
      var _a;
      if (!selectionType) {
        throw new Error("Invariant violation: calling selection props with missing selection type.");
      }
      return {
        name: selectionName,
        selectionType,
        ariaLabel: joinStrings(ariaLabels === null || ariaLabels === void 0 ? void 0 : ariaLabels.selectionGroupLabel, (_a = ariaLabels === null || ariaLabels === void 0 ? void 0 : ariaLabels.itemSelectionLabel) === null || _a === void 0 ? void 0 : _a.call(ariaLabels, { selectedItems }, item)),
        onChange: handleToggleItem(item),
        checked: isItemSelected(item),
        disabled: isItemDisabled(item)
      };
    },
    updateShiftToggle: (value) => {
      setShiftPressed(value);
    }
  };
}

// node_modules/@cloudscape-design/components/table/header-cell/index.js
var import_react17 = __toESM(require_react());

// node_modules/@cloudscape-design/components/table/header-cell/utils.js
var stateToIcon = {
  sortable: "caret-down",
  ascending: "caret-up-filled",
  descending: "caret-down-filled"
};
var getSortingStatus = (sortable, sorted, descending, disabled) => {
  if (sorted) {
    if (descending) {
      return "descending";
    }
    return "ascending";
  }
  if (sortable && !disabled) {
    return "sortable";
  }
  return void 0;
};
var getSortingIconName = (sortingState) => stateToIcon[sortingState];
var isSorted = (column, sortingColumn) => column === sortingColumn || column.sortingField !== void 0 && column.sortingField === sortingColumn.sortingField || column.sortingComparator !== void 0 && column.sortingComparator === sortingColumn.sortingComparator;

// node_modules/@cloudscape-design/components/table/header-cell/styles.css.js
import "/home/a171157/personal-repos/deep-racer/community-contributions/deepracer-custom-console/new/node_modules/@cloudscape-design/components/table/header-cell/styles.scoped.css";
var styles_css_default5 = {
  "header-cell": "awsui_header-cell_1spae_1sbf1_99",
  "header-cell-fake-focus": "awsui_header-cell-fake-focus_1spae_1sbf1_133",
  "header-cell-sticky": "awsui_header-cell-sticky_1spae_1sbf1_154",
  "header-cell-stuck": "awsui_header-cell-stuck_1spae_1sbf1_157",
  "header-cell-variant-full-page": "awsui_header-cell-variant-full-page_1spae_1sbf1_157",
  "header-cell-hidden": "awsui_header-cell-hidden_1spae_1sbf1_160",
  "header-cell-sortable": "awsui_header-cell-sortable_1spae_1sbf1_163",
  "sticky-cell": "awsui_sticky-cell_1spae_1sbf1_166",
  "sticky-cell-pad-left": "awsui_sticky-cell-pad-left_1spae_1sbf1_174",
  "has-selection": "awsui_has-selection_1spae_1sbf1_174",
  "sticky-cell-last-left": "awsui_sticky-cell-last-left_1spae_1sbf1_177",
  "resize-divider": "awsui_resize-divider_1spae_1sbf1_181",
  "sticky-cell-last-right": "awsui_sticky-cell-last-right_1spae_1sbf1_184",
  "sorting-icon": "awsui_sorting-icon_1spae_1sbf1_199",
  "edit-icon": "awsui_edit-icon_1spae_1sbf1_207",
  "header-cell-content": "awsui_header-cell-content_1spae_1sbf1_213",
  "header-cell-content-expandable": "awsui_header-cell-content-expandable_1spae_1sbf1_219",
  "header-cell-disabled": "awsui_header-cell-disabled_1spae_1sbf1_271",
  "header-cell-sorted": "awsui_header-cell-sorted_1spae_1sbf1_271",
  "header-cell-text": "awsui_header-cell-text_1spae_1sbf1_285",
  "header-cell-text-wrap": "awsui_header-cell-text-wrap_1spae_1sbf1_289",
  "header-cell-ascending": "awsui_header-cell-ascending_1spae_1sbf1_295",
  "header-cell-descending": "awsui_header-cell-descending_1spae_1sbf1_296",
  "is-visual-refresh": "awsui_is-visual-refresh_1spae_1sbf1_306",
  "has-striped-rows": "awsui_has-striped-rows_1spae_1sbf1_320"
};

// node_modules/@cloudscape-design/components/table/resizer/index.js
var import_react10 = __toESM(require_react());

// node_modules/@cloudscape-design/components/table/resizer/styles.css.js
import "/home/a171157/personal-repos/deep-racer/community-contributions/deepracer-custom-console/new/node_modules/@cloudscape-design/components/table/resizer/styles.scoped.css";
var styles_css_default6 = {
  "resize-active": "awsui_resize-active_x7peu_sqn6e_99",
  "resize-active-with-focus": "awsui_resize-active-with-focus_x7peu_sqn6e_99",
  "divider": "awsui_divider_x7peu_sqn6e_104",
  "divider-disabled": "awsui_divider-disabled_x7peu_sqn6e_118",
  "divider-active": "awsui_divider-active_x7peu_sqn6e_121",
  "resizer": "awsui_resizer_x7peu_sqn6e_125",
  "has-focus": "awsui_has-focus_x7peu_sqn6e_182",
  "tracker": "awsui_tracker_x7peu_sqn6e_205"
};

// node_modules/@cloudscape-design/components/table/use-column-widths.js
var import_react9 = __toESM(require_react());

// node_modules/@cloudscape-design/components/table/column-widths-utils.js
function checkColumnWidths(columnDefinitions) {
  for (const column of columnDefinitions) {
    checkProperty(column, "minWidth");
    checkProperty(column, "width");
  }
}
function setElementWidths(element, styles) {
  function setProperty(property) {
    const value = styles[property];
    let widthCssValue = "";
    if (typeof value === "number") {
      widthCssValue = value + "px";
    }
    if (typeof value === "string") {
      widthCssValue = value;
    }
    if (element.style[property] !== widthCssValue) {
      element.style[property] = widthCssValue;
    }
  }
  setProperty("width");
  setProperty("minWidth");
  setProperty("maxWidth");
}
function checkProperty(column, name) {
  const value = column[name];
  if (typeof value !== "number" && typeof value !== "undefined") {
    warnOnce("Table", `resizableColumns feature requires ${name} property to be a number, got ${value}. The component may work incorrectly.`);
  }
}

// node_modules/@cloudscape-design/components/table/use-column-widths.js
var DEFAULT_COLUMN_WIDTH = 120;
function readWidths(getCell, visibleColumns) {
  var _a;
  const result = /* @__PURE__ */ new Map();
  for (let index = 0; index < visibleColumns.length; index++) {
    const column = visibleColumns[index];
    let width = column.width || 0;
    const minWidth = column.minWidth || width || DEFAULT_COLUMN_WIDTH;
    if (!width && // read width from the DOM if it is missing in the config
    index !== visibleColumns.length - 1) {
      const colEl = getCell(column.id);
      width = (_a = colEl === null || colEl === void 0 ? void 0 : colEl.getBoundingClientRect().width) !== null && _a !== void 0 ? _a : DEFAULT_COLUMN_WIDTH;
    }
    result.set(column.id, Math.max(width, minWidth));
  }
  return result;
}
function updateWidths(visibleColumns, oldWidths, newWidth, columnId) {
  const column = visibleColumns.find((column2) => column2.id === columnId);
  const minWidth = typeof (column === null || column === void 0 ? void 0 : column.minWidth) === "number" ? column.minWidth : DEFAULT_COLUMN_WIDTH;
  newWidth = Math.max(newWidth, minWidth);
  if (oldWidths.get(columnId) === newWidth) {
    return oldWidths;
  }
  const newWidths = new Map(oldWidths);
  newWidths.set(columnId, newWidth);
  return newWidths;
}
var WidthsContext = (0, import_react9.createContext)({
  getColumnStyles: () => ({}),
  columnWidths: /* @__PURE__ */ new Map(),
  updateColumn: () => {
  },
  setCell: () => {
  }
});
function ColumnWidthsProvider({ visibleColumns, resizableColumns, containerRef, children }) {
  const visibleColumnsRef = (0, import_react9.useRef)(null);
  const containerWidthRef = (0, import_react9.useRef)(0);
  const [columnWidths, setColumnWidths] = (0, import_react9.useState)(null);
  const cellsRef = (0, import_react9.useRef)(/* @__PURE__ */ new Map());
  const stickyCellsRef = (0, import_react9.useRef)(/* @__PURE__ */ new Map());
  const getCell = (columnId) => {
    var _a;
    return (_a = cellsRef.current.get(columnId)) !== null && _a !== void 0 ? _a : null;
  };
  const setCell = (sticky, columnId, node) => {
    const ref = sticky ? stickyCellsRef : cellsRef;
    if (node) {
      ref.current.set(columnId, node);
    } else {
      ref.current.delete(columnId);
    }
  };
  const getColumnStyles = (sticky, columnId) => {
    var _a, _b, _c;
    const column = visibleColumns.find((column2) => column2.id === columnId);
    if (!column) {
      return {};
    }
    if (sticky) {
      return { width: ((_a = cellsRef.current.get(column.id)) === null || _a === void 0 ? void 0 : _a.offsetWidth) || ((_b = columnWidths === null || columnWidths === void 0 ? void 0 : columnWidths.get(column.id)) !== null && _b !== void 0 ? _b : column.width) };
    }
    if (resizableColumns && columnWidths) {
      const isLastColumn = column.id === ((_c = visibleColumns[visibleColumns.length - 1]) === null || _c === void 0 ? void 0 : _c.id);
      const totalWidth = visibleColumns.reduce((sum, { id }) => sum + (columnWidths.get(id) || DEFAULT_COLUMN_WIDTH), 0);
      if (isLastColumn && containerWidthRef.current > totalWidth) {
        return { width: "auto", minWidth: column === null || column === void 0 ? void 0 : column.minWidth };
      } else {
        return { width: columnWidths.get(column.id), minWidth: column === null || column === void 0 ? void 0 : column.minWidth };
      }
    }
    return {
      width: column.width,
      minWidth: column.minWidth,
      maxWidth: !resizableColumns ? column.maxWidth : void 0
    };
  };
  const updateColumnWidths = useStableCallback(() => {
    for (const { id } of visibleColumns) {
      const element = cellsRef.current.get(id);
      if (element) {
        setElementWidths(element, getColumnStyles(false, id));
      }
    }
    for (const { id } of visibleColumns) {
      const element = stickyCellsRef.current.get(id);
      if (element) {
        setElementWidths(element, getColumnStyles(true, id));
      }
    }
  });
  useResizeObserver(containerRef, ({ contentBoxWidth: containerWidth }) => {
    containerWidthRef.current = containerWidth;
    updateColumnWidths();
  });
  (0, import_react9.useEffect)(() => {
    updateColumnWidths();
    if (!resizableColumns) {
      return;
    }
    let updated = false;
    const newColumnWidths = new Map(columnWidths);
    const lastVisible = visibleColumnsRef.current;
    if (lastVisible) {
      for (let index = 0; index < visibleColumns.length; index++) {
        const column = visibleColumns[index];
        if (!(columnWidths === null || columnWidths === void 0 ? void 0 : columnWidths.get(column.id)) && lastVisible.indexOf(column.id) === -1) {
          updated = true;
          newColumnWidths.set(column.id, column.width || DEFAULT_COLUMN_WIDTH);
        }
      }
      if (updated) {
        setColumnWidths(newColumnWidths);
      }
    }
    visibleColumnsRef.current = visibleColumns.map((column) => column.id);
  }, [columnWidths, resizableColumns, visibleColumns, updateColumnWidths]);
  (0, import_react9.useEffect)(() => {
    if (!resizableColumns) {
      return;
    }
    setColumnWidths(() => readWidths(getCell, visibleColumns));
  }, []);
  function updateColumn(columnId, newWidth) {
    setColumnWidths((columnWidths2) => updateWidths(visibleColumns, columnWidths2 !== null && columnWidths2 !== void 0 ? columnWidths2 : /* @__PURE__ */ new Map(), newWidth, columnId));
  }
  return import_react9.default.createElement(WidthsContext.Provider, { value: { getColumnStyles, columnWidths: columnWidths !== null && columnWidths !== void 0 ? columnWidths : /* @__PURE__ */ new Map(), updateColumn, setCell } }, children);
}
function useColumnWidths() {
  return (0, import_react9.useContext)(WidthsContext);
}

// node_modules/@cloudscape-design/components/table/resizer/resizer-lookup.js
function getResizerElements(resizerElement) {
  if (!resizerElement) {
    return null;
  }
  const header = findUpUntil(resizerElement, (element) => element.tagName.toLowerCase() === "th");
  if (!header) {
    return null;
  }
  const tableRoot = findUpUntil(header, (element) => element.className.indexOf(styles_css_default3.root) > -1);
  if (!tableRoot) {
    return null;
  }
  const table = tableRoot.querySelector(`table`);
  if (!table) {
    return null;
  }
  const tracker = tableRoot.querySelector(`.${styles_css_default6.tracker}`);
  if (!tracker) {
    return null;
  }
  const scrollParent = getOverflowParents(header)[0];
  if (!scrollParent) {
    return null;
  }
  return { header, table, tracker, scrollParent };
}
function getHeaderWidth(resizerElement) {
  var _a;
  const header = resizerElement && findUpUntil(resizerElement, (element) => element.tagName.toLowerCase() === "th");
  return (_a = header === null || header === void 0 ? void 0 : header.getBoundingClientRect().width) !== null && _a !== void 0 ? _a : 0;
}

// node_modules/@cloudscape-design/components/table/resizer/index.js
var AUTO_GROW_START_TIME = 10;
var AUTO_GROW_INTERVAL = 10;
var AUTO_GROW_INCREMENT = 5;
function Divider({ className }) {
  return import_react10.default.createElement("span", { className: clsx_m_default(styles_css_default6.divider, styles_css_default6["divider-disabled"], className) });
}
function Resizer({ onWidthUpdate, onWidthUpdateCommit, ariaLabelledby, minWidth = DEFAULT_COLUMN_WIDTH, tabIndex, showFocusRing, focusId, roleDescription }) {
  onWidthUpdate = useStableCallback(onWidthUpdate);
  onWidthUpdateCommit = useStableCallback(onWidthUpdateCommit);
  const separatorId = useUniqueId();
  const resizerToggleRef = (0, import_react10.useRef)(null);
  const resizerSeparatorRef = (0, import_react10.useRef)(null);
  const [isDragging, setIsDragging] = (0, import_react10.useState)(false);
  const [isKeyboardDragging, setIsKeyboardDragging] = (0, import_react10.useState)(false);
  const autoGrowTimeout = (0, import_react10.useRef)();
  const [resizerHasFocus, setResizerHasFocus] = (0, import_react10.useState)(false);
  const [headerCellWidth, setHeaderCellWidth] = (0, import_react10.useState)(0);
  (0, import_react10.useEffect)(() => {
    setHeaderCellWidth(getHeaderWidth(resizerToggleRef.current));
  }, []);
  (0, import_react10.useEffect)(() => {
    const elements = getResizerElements(resizerToggleRef.current);
    if (!isDragging && !resizerHasFocus || !elements) {
      return;
    }
    const { left: leftEdge, right: rightEdge } = elements.scrollParent.getBoundingClientRect();
    const updateTrackerPosition = (newOffset) => {
      const { left: scrollParentLeft } = elements.table.getBoundingClientRect();
      elements.tracker.style.top = elements.header.getBoundingClientRect().height + "px";
      elements.tracker.style.left = newOffset - scrollParentLeft - 1 + "px";
    };
    const updateColumnWidth = (newWidth) => {
      const { right, width } = elements.header.getBoundingClientRect();
      const updatedWidth = newWidth < minWidth ? minWidth : newWidth;
      updateTrackerPosition(right + updatedWidth - width);
      if (newWidth >= minWidth) {
        setHeaderCellWidth(newWidth);
      }
      onWidthUpdate(newWidth);
    };
    const resizeColumn = (offset) => {
      if (offset > leftEdge) {
        const cellLeft = elements.header.getBoundingClientRect().left;
        const newWidth = offset - cellLeft;
        updateColumnWidth(newWidth);
      }
    };
    const onAutoGrow = () => {
      const width = elements.header.getBoundingClientRect().width;
      autoGrowTimeout.current = setTimeout(onAutoGrow, AUTO_GROW_INTERVAL);
      updateColumnWidth(width + AUTO_GROW_INCREMENT);
      elements.scrollParent.scrollLeft += AUTO_GROW_INCREMENT;
    };
    const onMouseMove = (event) => {
      clearTimeout(autoGrowTimeout.current);
      const offset = event.pageX;
      if (offset > rightEdge) {
        autoGrowTimeout.current = setTimeout(onAutoGrow, AUTO_GROW_START_TIME);
      } else {
        resizeColumn(offset);
      }
    };
    const onMouseUp = (event) => {
      resizeColumn(event.pageX);
      setIsDragging(false);
      onWidthUpdateCommit();
      clearTimeout(autoGrowTimeout.current);
    };
    const onKeyDown = (event) => {
      var _a, _b;
      if (isKeyboardDragging) {
        if (event.keyCode === KeyCode.left) {
          event.preventDefault();
          updateColumnWidth(elements.header.getBoundingClientRect().width - 10);
        }
        if (event.keyCode === KeyCode.right) {
          event.preventDefault();
          updateColumnWidth(elements.header.getBoundingClientRect().width + 10);
        }
        if (event.keyCode === KeyCode.enter || event.keyCode === KeyCode.space || event.keyCode === KeyCode.escape) {
          event.preventDefault();
          setIsKeyboardDragging(false);
          (_a = resizerToggleRef.current) === null || _a === void 0 ? void 0 : _a.focus();
        }
      } else if (event.keyCode === KeyCode.enter || event.keyCode === KeyCode.space) {
        event.preventDefault();
        setIsKeyboardDragging(true);
        (_b = resizerSeparatorRef.current) === null || _b === void 0 ? void 0 : _b.focus();
      }
    };
    updateTrackerPosition(elements.header.getBoundingClientRect().right);
    if (isDragging) {
      document.body.classList.add(styles_css_default6["resize-active"]);
      document.addEventListener("mousemove", onMouseMove);
      document.addEventListener("mouseup", onMouseUp);
    }
    if (resizerHasFocus) {
      document.body.classList.add(styles_css_default6["resize-active-with-focus"]);
      elements.header.addEventListener("keydown", onKeyDown);
    }
    if (isKeyboardDragging) {
      document.body.classList.add(styles_css_default6["resize-active"]);
    }
    return () => {
      clearTimeout(autoGrowTimeout.current);
      document.body.classList.remove(styles_css_default6["resize-active"]);
      document.body.classList.remove(styles_css_default6["resize-active-with-focus"]);
      document.removeEventListener("mousemove", onMouseMove);
      document.removeEventListener("mouseup", onMouseUp);
      elements.header.removeEventListener("keydown", onKeyDown);
    };
  }, [minWidth, isDragging, isKeyboardDragging, resizerHasFocus, onWidthUpdate, onWidthUpdateCommit]);
  const { tabIndex: resizerTabIndex } = useSingleTabStopNavigation(resizerToggleRef, { tabIndex });
  return import_react10.default.createElement(
    import_react10.default.Fragment,
    null,
    import_react10.default.createElement("button", { ref: resizerToggleRef, className: clsx_m_default(styles_css_default6.resizer, (resizerHasFocus || showFocusRing || isKeyboardDragging) && styles_css_default6["has-focus"]), onMouseDown: (event) => {
      if (event.button !== 0) {
        return;
      }
      event.preventDefault();
      setIsDragging(true);
    }, onClick: () => {
      var _a;
      setIsDragging(false);
      setResizerHasFocus(true);
      setIsKeyboardDragging(true);
      (_a = resizerSeparatorRef.current) === null || _a === void 0 ? void 0 : _a.focus();
    }, onFocus: () => {
      setHeaderCellWidth(getHeaderWidth(resizerToggleRef.current));
      setResizerHasFocus(true);
    }, onBlur: (event) => {
      if (event.relatedTarget !== resizerSeparatorRef.current) {
        setResizerHasFocus(false);
      }
    }, "aria-roledescription": roleDescription, "aria-labelledby": ariaLabelledby, tabIndex: resizerTabIndex, "data-focus-id": focusId }),
    import_react10.default.createElement("span", { className: clsx_m_default(styles_css_default6.divider, isDragging && styles_css_default6["divider-active"]), "data-awsui-table-suppress-navigation": true, ref: resizerSeparatorRef, id: separatorId, role: "separator", tabIndex: -1, "aria-hidden": !isKeyboardDragging, "aria-orientation": "vertical", "aria-valuenow": headerCellWidth, "aria-valuetext": headerCellWidth.toFixed(0), "aria-valuemin": minWidth, "data-focus-id": focusId, onBlur: () => {
      setResizerHasFocus(false);
      if (isKeyboardDragging) {
        setIsKeyboardDragging(false);
      }
      onWidthUpdateCommit();
    } })
  );
}
function ResizeTracker() {
  return import_react10.default.createElement("span", { className: styles_css_default6.tracker });
}

// node_modules/@cloudscape-design/components/table/header-cell/th-element.js
var import_react16 = __toESM(require_react());

// node_modules/@cloudscape-design/components/table/sticky-columns/use-sticky-columns.js
var import_react13 = __toESM(require_react());

// node_modules/@cloudscape-design/components/area-chart/async-store/index.js
var import_react12 = __toESM(require_react());
var import_react_dom = __toESM(require_react_dom());

// node_modules/@cloudscape-design/components/internal/hooks/use-previous/index.js
var import_react11 = __toESM(require_react());
var usePrevious = (value) => {
  const ref = (0, import_react11.useRef)();
  (0, import_react11.useEffect)(() => {
    ref.current = value;
  });
  return ref.current;
};

// node_modules/@cloudscape-design/components/area-chart/async-store/index.js
var AsyncStore = class {
  constructor(state) {
    this._listeners = [];
    this._state = state;
  }
  get() {
    return this._state;
  }
  set(cb) {
    const prevState = this._state;
    const newState = cb(prevState);
    this._state = newState;
    (0, import_react_dom.unstable_batchedUpdates)(() => {
      for (const [selector, listener] of this._listeners) {
        if (selector(prevState) !== selector(newState)) {
          listener(newState, prevState);
        }
      }
    });
  }
  subscribe(selector, listener) {
    this._listeners.push([selector, listener]);
    return () => this.unsubscribe(listener);
  }
  unsubscribe(listener) {
    for (let index = 0; index < this._listeners.length; index++) {
      const [, storedListener] = this._listeners[index];
      if (storedListener === listener) {
        this._listeners.splice(index, 1);
        break;
      }
    }
  }
};
function useReaction(store, selector, effect) {
  (0, import_react12.useLayoutEffect)(
    () => {
      const unsubscribe = store.subscribe(selector, (newState, prevState) => effect(selector(newState), selector(prevState)));
      return unsubscribe;
    },
    // ignoring selector and effect as they are expected to stay constant
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [store]
  );
}
function useSelector(store, selector) {
  const [state, setState] = (0, import_react12.useState)(selector(store.get()));
  useReaction(store, selector, (newState) => {
    setState(newState);
  });
  const prevStore = usePrevious(store);
  if (prevStore !== null && prevStore !== store) {
    return selector(store.get());
  }
  return state;
}

// node_modules/@cloudscape-design/components/table/sticky-columns/utils.js
function isCellStatesEqual(s1, s2) {
  if (s1 && s2) {
    return s1.padLeft === s2.padLeft && s1.lastLeft === s2.lastLeft && s1.lastRight === s2.lastRight && s1.offset.left === s2.offset.left && s1.offset.right === s2.offset.right;
  }
  return s1 === s2;
}
function isWrapperStatesEqual(s1, s2) {
  return s1.scrollPaddingLeft === s2.scrollPaddingLeft && s1.scrollPaddingRight === s2.scrollPaddingRight;
}
function updateCellOffsets(cells, props) {
  var _a, _b, _c, _d, _e, _f;
  const totalColumns = props.visibleColumns.length;
  const firstColumnsWidths = [];
  for (let i = 0; i < Math.min(totalColumns, props.stickyColumnsFirst); i++) {
    const element = cells.get(props.visibleColumns[i]);
    const cellWidth = (_a = element === null || element === void 0 ? void 0 : element.getBoundingClientRect().width) !== null && _a !== void 0 ? _a : 0;
    firstColumnsWidths[i] = ((_b = firstColumnsWidths[i - 1]) !== null && _b !== void 0 ? _b : 0) + cellWidth;
  }
  const lastColumnsWidths = [];
  for (let i = 0; i < Math.min(totalColumns, props.stickyColumnsLast); i++) {
    const element = cells.get(props.visibleColumns[totalColumns - 1 - i]);
    const cellWidth = (_c = element === null || element === void 0 ? void 0 : element.getBoundingClientRect().width) !== null && _c !== void 0 ? _c : 0;
    lastColumnsWidths[i] = ((_d = lastColumnsWidths[i - 1]) !== null && _d !== void 0 ? _d : 0) + cellWidth;
  }
  const stickyWidthLeft = (_e = firstColumnsWidths[props.stickyColumnsFirst - 1]) !== null && _e !== void 0 ? _e : 0;
  const stickyWidthRight = (_f = lastColumnsWidths[props.stickyColumnsLast - 1]) !== null && _f !== void 0 ? _f : 0;
  const offsets = props.visibleColumns.reduce((map, columnId, columnIndex) => {
    var _a2, _b2;
    return map.set(columnId, {
      first: (_a2 = firstColumnsWidths[columnIndex - 1]) !== null && _a2 !== void 0 ? _a2 : 0,
      last: (_b2 = lastColumnsWidths[totalColumns - 1 - columnIndex - 1]) !== null && _b2 !== void 0 ? _b2 : 0
    });
  }, /* @__PURE__ */ new Map());
  return { offsets, stickyWidthLeft, stickyWidthRight };
}

// node_modules/@cloudscape-design/components/table/sticky-columns/use-sticky-columns.js
var MINIMUM_SCROLLABLE_SPACE = 148;
function useStickyColumns({ visibleColumns, stickyColumnsFirst, stickyColumnsLast }) {
  const store = (0, import_react13.useMemo)(() => new StickyColumnsStore(), []);
  const wrapperRef = (0, import_react13.useRef)(null);
  const tableRef = (0, import_react13.useRef)(null);
  const cellsRef = (0, import_react13.useRef)(/* @__PURE__ */ new Map());
  const hasStickyColumns = stickyColumnsFirst + stickyColumnsLast > 0;
  const updateStickyStyles = useStableCallback(() => {
    if (wrapperRef.current && tableRef.current) {
      store.updateCellStyles({
        wrapper: wrapperRef.current,
        table: tableRef.current,
        cells: cellsRef.current,
        visibleColumns,
        stickyColumnsFirst,
        stickyColumnsLast
      });
    }
  });
  useResizeObserver(wrapperRef, updateStickyStyles);
  useResizeObserver(tableRef, updateStickyStyles);
  (0, import_react13.useEffect)(() => {
    if (wrapperRef.current && tableRef.current) {
      store.updateCellStyles({
        wrapper: wrapperRef.current,
        table: tableRef.current,
        cells: cellsRef.current,
        visibleColumns,
        stickyColumnsFirst,
        stickyColumnsLast
      });
    }
  }, [store, stickyColumnsFirst, stickyColumnsLast, visibleColumns]);
  (0, import_react13.useEffect)(() => {
    if (!hasStickyColumns) {
      return;
    }
    const selector = (state) => state.wrapperState;
    const updateWrapperStyles = (state, prev) => {
      if (isWrapperStatesEqual(state, prev)) {
        return;
      }
      if (wrapperRef.current) {
        wrapperRef.current.style.scrollPaddingLeft = state.scrollPaddingLeft + "px";
        wrapperRef.current.style.scrollPaddingRight = state.scrollPaddingRight + "px";
      }
    };
    const unsubscribe = store.subscribe(selector, (newState, prevState) => updateWrapperStyles(selector(newState), selector(prevState)));
    return unsubscribe;
  }, [store, hasStickyColumns]);
  const setWrapper = (0, import_react13.useCallback)((node) => {
    if (wrapperRef.current) {
      wrapperRef.current.removeEventListener("scroll", updateStickyStyles);
    }
    if (node && hasStickyColumns) {
      node.addEventListener("scroll", updateStickyStyles);
    }
    wrapperRef.current = node;
  }, [hasStickyColumns, updateStickyStyles]);
  const setTable = (0, import_react13.useCallback)((node) => {
    tableRef.current = node;
  }, []);
  const setCell = (0, import_react13.useCallback)((columnId, node) => {
    if (node) {
      cellsRef.current.set(columnId, node);
    } else {
      cellsRef.current.delete(columnId);
    }
  }, []);
  return {
    store,
    style: {
      // Provide wrapper styles as props so that a re-render won't cause invalidation.
      wrapper: hasStickyColumns ? Object.assign({}, store.get().wrapperState) : void 0
    },
    refs: { wrapper: setWrapper, table: setTable, cell: setCell }
  };
}
function useStickyCellStyles({ stickyColumns, columnId, getClassName }) {
  var _a;
  const setCell = stickyColumns.refs.cell;
  const unsubscribeRef = (0, import_react13.useRef)(null);
  const refCallback = (0, import_react13.useCallback)(
    (cellElement) => {
      if (unsubscribeRef.current) {
        unsubscribeRef.current();
      }
      setCell(columnId, cellElement);
      const selector = (state) => {
        var _a2;
        return (_a2 = state.cellState.get(columnId)) !== null && _a2 !== void 0 ? _a2 : null;
      };
      const updateCellStyles = (state, prev) => {
        if (isCellStatesEqual(state, prev)) {
          return;
        }
        const className = getClassName(state);
        if (cellElement) {
          Object.keys(className).forEach((key) => {
            if (className[key]) {
              cellElement.classList.add(key);
            } else {
              cellElement.classList.remove(key);
            }
          });
          cellElement.style.left = (state === null || state === void 0 ? void 0 : state.offset.left) !== void 0 ? `${state.offset.left}px` : "";
          cellElement.style.right = (state === null || state === void 0 ? void 0 : state.offset.right) !== void 0 ? `${state.offset.right}px` : "";
        }
      };
      if (cellElement) {
        unsubscribeRef.current = stickyColumns.store.subscribe(selector, (newState, prevState) => {
          updateCellStyles(selector(newState), selector(prevState));
        });
      }
    },
    // getClassName is expected to be pure
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [columnId, setCell, stickyColumns.store]
  );
  const cellStyles = stickyColumns.store.get().cellState.get(columnId);
  return {
    ref: refCallback,
    className: cellStyles ? clsx_m_default(getClassName(cellStyles)) : void 0,
    style: (_a = cellStyles === null || cellStyles === void 0 ? void 0 : cellStyles.offset) !== null && _a !== void 0 ? _a : void 0
  };
}
var StickyColumnsStore = class extends AsyncStore {
  constructor() {
    super({ cellState: /* @__PURE__ */ new Map(), wrapperState: { scrollPaddingLeft: 0, scrollPaddingRight: 0 } });
    this.cellOffsets = {
      offsets: /* @__PURE__ */ new Map(),
      stickyWidthLeft: 0,
      stickyWidthRight: 0
    };
    this.isStuckToTheLeft = false;
    this.isStuckToTheRight = false;
    this.padLeft = false;
    this.generateCellStyles = (props) => {
      const isEnabled = this.isEnabled(props);
      const lastLeftStickyColumnIndex = props.stickyColumnsFirst - 1;
      const lastRightStickyColumnIndex = props.visibleColumns.length - props.stickyColumnsLast;
      return props.visibleColumns.reduce((acc, columnId, index) => {
        var _a, _b, _c, _d;
        let stickySide = "non-sticky";
        if (index < props.stickyColumnsFirst) {
          stickySide = "left";
        } else if (index >= props.visibleColumns.length - props.stickyColumnsLast) {
          stickySide = "right";
        }
        if (!isEnabled || stickySide === "non-sticky") {
          return acc;
        }
        const isFirstColumn = index === 0;
        const stickyColumnOffsetLeft = (_b = (_a = this.cellOffsets.offsets.get(columnId)) === null || _a === void 0 ? void 0 : _a.first) !== null && _b !== void 0 ? _b : 0;
        const stickyColumnOffsetRight = (_d = (_c = this.cellOffsets.offsets.get(columnId)) === null || _c === void 0 ? void 0 : _c.last) !== null && _d !== void 0 ? _d : 0;
        acc.set(columnId, {
          padLeft: isFirstColumn && this.padLeft,
          lastLeft: this.isStuckToTheLeft && lastLeftStickyColumnIndex === index,
          lastRight: this.isStuckToTheRight && lastRightStickyColumnIndex === index,
          offset: {
            left: stickySide === "left" ? stickyColumnOffsetLeft : void 0,
            right: stickySide === "right" ? stickyColumnOffsetRight : void 0
          }
        });
        return acc;
      }, /* @__PURE__ */ new Map());
    };
    this.updateCellOffsets = (props) => {
      this.cellOffsets = updateCellOffsets(props.cells, props);
    };
    this.isEnabled = (props) => {
      const noStickyColumns = props.stickyColumnsFirst + props.stickyColumnsLast === 0;
      if (noStickyColumns) {
        return false;
      }
      const wrapperWidth = props.wrapper.getBoundingClientRect().width;
      const tableWidth = props.table.getBoundingClientRect().width;
      const isWrapperScrollable = tableWidth > wrapperWidth;
      if (!isWrapperScrollable) {
        return false;
      }
      const totalStickySpace = this.cellOffsets.stickyWidthLeft + this.cellOffsets.stickyWidthRight;
      const tablePaddingLeft = parseFloat(getComputedStyle(props.table).paddingLeft) || 0;
      const tablePaddingRight = parseFloat(getComputedStyle(props.table).paddingRight) || 0;
      const hasEnoughScrollableSpace = totalStickySpace + MINIMUM_SCROLLABLE_SPACE + tablePaddingLeft + tablePaddingRight < wrapperWidth;
      if (!hasEnoughScrollableSpace) {
        return false;
      }
      return true;
    };
  }
  updateCellStyles(props) {
    const hasStickyColumns = props.stickyColumnsFirst + props.stickyColumnsLast > 0;
    const hadStickyColumns = this.cellOffsets.offsets.size > 0;
    if (hasStickyColumns || hadStickyColumns) {
      this.updateScroll(props);
      this.updateCellOffsets(props);
      this.set(() => ({
        cellState: this.generateCellStyles(props),
        wrapperState: {
          scrollPaddingLeft: this.cellOffsets.stickyWidthLeft,
          scrollPaddingRight: this.cellOffsets.stickyWidthRight
        }
      }));
    }
  }
  updateScroll(props) {
    const wrapperScrollLeft = props.wrapper.scrollLeft;
    const wrapperScrollWidth = props.wrapper.scrollWidth;
    const wrapperClientWidth = props.wrapper.clientWidth;
    const tablePaddingLeft = parseFloat(getComputedStyle(props.table).paddingLeft) || 0;
    const tablePaddingRight = parseFloat(getComputedStyle(props.table).paddingRight) || 0;
    this.isStuckToTheLeft = wrapperScrollLeft > tablePaddingLeft;
    this.isStuckToTheRight = Math.ceil(wrapperScrollLeft) < wrapperScrollWidth - wrapperClientWidth - tablePaddingRight;
    this.padLeft = tablePaddingLeft !== 0 && this.isStuckToTheLeft;
  }
};

// node_modules/@cloudscape-design/components/table/table-role/table-role-helper.js
var stateToAriaSort = {
  sortable: "none",
  ascending: "ascending",
  descending: "descending"
};
var getAriaSort = (sortingState) => stateToAriaSort[sortingState];
function getTableRoleProps(options) {
  const nativeProps = {};
  nativeProps.role = options.tableRole === "grid-default" ? "grid" : options.tableRole;
  nativeProps["aria-label"] = options.ariaLabel;
  nativeProps["aria-labelledby"] = options.ariaLabelledBy;
  nativeProps["aria-rowcount"] = options.totalItemsCount ? options.totalItemsCount + 1 : -1;
  if (options.tableRole === "grid" || options.tableRole === "treegrid") {
    nativeProps["aria-colcount"] = options.totalColumnsCount;
  }
  if (options.tableRole === "grid" || options.tableRole === "treegrid") {
    nativeProps.tabIndex = -1;
  }
  return nativeProps;
}
function getTableWrapperRoleProps(options) {
  const nativeProps = {};
  if (options.isScrollable) {
    nativeProps.role = "region";
    nativeProps.tabIndex = 0;
    nativeProps["aria-label"] = options.ariaLabel;
  }
  return nativeProps;
}
function getTableHeaderRowRoleProps(options) {
  const nativeProps = {};
  if (options.tableRole === "grid" || options.tableRole === "grid-default" || options.tableRole === "treegrid") {
    nativeProps["aria-rowindex"] = 1;
  }
  return nativeProps;
}
function getTableRowRoleProps(options) {
  const nativeProps = {};
  if (options.tableRole === "grid" || options.tableRole === "treegrid") {
    nativeProps["aria-rowindex"] = (options.firstIndex || 1) + options.rowIndex + 1;
  } else if (options.firstIndex !== void 0) {
    nativeProps["aria-rowindex"] = options.firstIndex + options.rowIndex + 1;
  }
  if (options.tableRole === "treegrid" && options.level && options.level !== 0) {
    nativeProps["aria-level"] = options.level;
  }
  if (options.tableRole === "treegrid" && options.setSize) {
    nativeProps["aria-setsize"] = options.setSize;
  }
  if (options.tableRole === "treegrid" && options.posInSet) {
    nativeProps["aria-posinset"] = options.posInSet;
  }
  return nativeProps;
}
function getTableColHeaderRoleProps(options) {
  const nativeProps = {};
  nativeProps.scope = "col";
  if (options.tableRole === "grid" || options.tableRole === "treegrid") {
    nativeProps["aria-colindex"] = options.colIndex + 1;
  }
  if (options.sortingStatus) {
    nativeProps["aria-sort"] = getAriaSort(options.sortingStatus);
  }
  return nativeProps;
}
function getTableCellRoleProps(options) {
  const nativeProps = {};
  if (options.tableRole === "grid" || options.tableRole === "treegrid") {
    nativeProps["aria-colindex"] = options.colIndex + 1;
  }
  if (options.isRowHeader) {
    nativeProps.scope = "row";
  }
  return nativeProps;
}

// node_modules/@cloudscape-design/components/table/table-role/grid-navigation.js
var import_react14 = __toESM(require_react());
var import_react15 = __toESM(require_react());

// node_modules/@cloudscape-design/components/table/table-role/utils.js
function getClosestCell(element) {
  return element.closest("td,th");
}
function isElementDisabled(element) {
  if (element instanceof HTMLInputElement || element instanceof HTMLButtonElement) {
    return element.disabled;
  }
  return false;
}
function defaultIsSuppressed(target) {
  let current = target;
  while (current) {
    if (isTableCell(current)) {
      return false;
    }
    if (current.getAttribute("role") === "dialog" || current.getAttribute("data-awsui-table-suppress-navigation") === "true") {
      return true;
    }
    current = current.parentElement;
  }
  return false;
}
function findTableRowByAriaRowIndex(table, targetAriaRowIndex, delta) {
  var _a;
  let targetRow = null;
  const rowElements = Array.from(table.querySelectorAll("tr[aria-rowindex]"));
  if (delta < 0) {
    rowElements.reverse();
  }
  for (const element of rowElements) {
    const rowIndex = parseInt((_a = element.getAttribute("aria-rowindex")) !== null && _a !== void 0 ? _a : "");
    targetRow = element;
    if (rowIndex === targetAriaRowIndex) {
      break;
    }
    if (delta >= 0 && rowIndex > targetAriaRowIndex) {
      break;
    }
    if (delta < 0 && rowIndex < targetAriaRowIndex) {
      break;
    }
  }
  return targetRow;
}
function findTableRowCellByAriaColIndex(tableRow, targetAriaColIndex, delta) {
  var _a;
  let targetCell = null;
  const cellElements = Array.from(tableRow.querySelectorAll("td[aria-colindex],th[aria-colindex]"));
  if (delta < 0) {
    cellElements.reverse();
  }
  for (const element of cellElements) {
    const columnIndex = parseInt((_a = element.getAttribute("aria-colindex")) !== null && _a !== void 0 ? _a : "");
    targetCell = element;
    if (columnIndex === targetAriaColIndex) {
      break;
    }
    if (delta >= 0 && columnIndex > targetAriaColIndex) {
      break;
    }
    if (delta < 0 && columnIndex < targetAriaColIndex) {
      break;
    }
  }
  return targetCell;
}
function isTableCell(element) {
  return element.tagName === "TD" || element.tagName === "TH";
}

// node_modules/@cloudscape-design/components/table/table-role/grid-navigation.js
function GridNavigationProvider({ keyboardNavigation, pageSize, getTable, children }) {
  const gridNavigation = (0, import_react15.useMemo)(() => new GridNavigationProcessor(), []);
  const getTableStable = useStableCallback(getTable);
  (0, import_react15.useEffect)(() => {
    if (keyboardNavigation) {
      const table = getTableStable();
      table && gridNavigation.init(table);
    }
    return () => gridNavigation.cleanup();
  }, [keyboardNavigation, gridNavigation, getTableStable]);
  (0, import_react15.useEffect)(() => {
    gridNavigation.update({ pageSize });
  }, [gridNavigation, pageSize]);
  (0, import_react15.useEffect)(() => {
    if (keyboardNavigation) {
      gridNavigation.refresh();
    }
  });
  return import_react14.default.createElement(SingleTabStopNavigationContext.Provider, { value: {
    navigationActive: keyboardNavigation,
    registerFocusable: gridNavigation.registerFocusable
  } }, children);
}
var GridNavigationProcessor = class {
  constructor() {
    this._pageSize = 0;
    this._table = null;
    this.focusedCell = null;
    this.keepUserIndex = false;
    this.focusables = /* @__PURE__ */ new Set();
    this.focusHandlers = /* @__PURE__ */ new Map();
    this.focusablesState = /* @__PURE__ */ new WeakMap();
    this.focusTarget = null;
    this.registerFocusable = (focusableElement, changeHandler) => {
      var _a, _b;
      this.focusables.add(focusableElement);
      this.focusHandlers.set(focusableElement, changeHandler);
      const isFocusable = (_a = this.focusablesState.get(focusableElement)) !== null && _a !== void 0 ? _a : false;
      const newIsFocusable = this.focusTarget === focusableElement || this.isSuppressed(focusableElement);
      if (newIsFocusable !== isFocusable) {
        this.focusablesState.set(focusableElement, newIsFocusable);
        changeHandler(newIsFocusable);
      }
      const focusedElement = (_b = this.focusedCell) === null || _b === void 0 ? void 0 : _b.element;
      if (focusedElement && isTableCell(focusedElement) && focusedElement.contains(focusableElement)) {
        focusableElement.focus({ preventScroll: true });
      }
      return () => this.unregisterFocusable(focusableElement);
    };
    this.unregisterFocusable = (focusable) => {
      this.focusables.delete(focusable);
      this.focusHandlers.delete(focusable);
    };
    this.onFocusin = (event) => {
      if (!(event.target instanceof HTMLElement)) {
        return;
      }
      this.updateFocusedCell(event.target);
      if (!this.focusedCell) {
        return;
      }
      this.updateFocusTarget();
      const focusedElement = this.focusedCell.element;
      const nextTarget = isTableCell(focusedElement) ? this.getFocusablesFrom(focusedElement)[0] : null;
      if (nextTarget) {
        nextTarget.focus({ preventScroll: true });
      } else {
        this.keepUserIndex = false;
      }
    };
    this.onFocusout = () => {
      setTimeout(() => {
        if (this.focusedCell && !nodeBelongs(this.table, this.focusedCell.element)) {
          this.moveFocusBy(this.focusedCell, { x: 0, y: 0 });
        }
      }, 0);
    };
    this.onKeydown = (event) => {
      if (!this.focusedCell) {
        return;
      }
      const ctrlKey = event.ctrlKey ? 1 : 0;
      const altKey = event.altKey ? 1 : 0;
      const shiftKey = event.shiftKey ? 1 : 0;
      const metaKey = event.metaKey ? 1 : 0;
      const numModifiersPressed = ctrlKey + altKey + shiftKey + metaKey;
      let key = event.keyCode;
      if (numModifiersPressed === 1 && event.ctrlKey) {
        key = -key;
      } else if (numModifiersPressed) {
        return;
      }
      const from = this.focusedCell;
      if (this.isSuppressed(document.activeElement) || !this.isRegistered(document.activeElement)) {
        return;
      }
      switch (key) {
        case KeyCode.up:
          event.preventDefault();
          return this.moveFocusBy(from, { y: -1, x: 0 });
        case KeyCode.down:
          event.preventDefault();
          return this.moveFocusBy(from, { y: 1, x: 0 });
        case KeyCode.left:
          event.preventDefault();
          return this.moveFocusBy(from, { y: 0, x: -1 });
        case KeyCode.right:
          event.preventDefault();
          return this.moveFocusBy(from, { y: 0, x: 1 });
        case KeyCode.pageUp:
          event.preventDefault();
          return this.moveFocusBy(from, { y: -this.pageSize, x: 0 });
        case KeyCode.pageDown:
          event.preventDefault();
          return this.moveFocusBy(from, { y: this.pageSize, x: 0 });
        case KeyCode.home:
          event.preventDefault();
          return this.moveFocusBy(from, { y: 0, x: -Infinity });
        case KeyCode.end:
          event.preventDefault();
          return this.moveFocusBy(from, { y: 0, x: Infinity });
        case -KeyCode.home:
          event.preventDefault();
          return this.moveFocusBy(from, { y: -Infinity, x: -Infinity });
        case -KeyCode.end:
          event.preventDefault();
          return this.moveFocusBy(from, { y: Infinity, x: Infinity });
        default:
          return;
      }
    };
  }
  init(table) {
    this._table = table;
    this.table.addEventListener("focusin", this.onFocusin);
    this.table.addEventListener("focusout", this.onFocusout);
    this.table.addEventListener("keydown", this.onKeydown);
    this.updateFocusTarget();
    this.cleanup = () => {
      this.table.removeEventListener("focusin", this.onFocusin);
      this.table.removeEventListener("focusout", this.onFocusout);
      this.table.removeEventListener("keydown", this.onKeydown);
      this.focusables.forEach(this.unregisterFocusable);
    };
  }
  cleanup() {
  }
  update({ pageSize }) {
    this._pageSize = pageSize;
  }
  refresh() {
    setTimeout(() => {
      var _a;
      if (this._table) {
        this.updateFocusedCell((_a = this.focusedCell) === null || _a === void 0 ? void 0 : _a.element);
        this.updateFocusTarget();
      }
    }, 0);
  }
  get pageSize() {
    return this._pageSize;
  }
  get table() {
    if (!this._table) {
      throw new Error("Invariant violation: GridNavigationProcessor is used before initialization.");
    }
    return this._table;
  }
  moveFocusBy(cell, delta) {
    var _a;
    if (delta.y !== 0 && delta.x === 0) {
      this.keepUserIndex = true;
    }
    (_a = this.getNextFocusable(cell, delta)) === null || _a === void 0 ? void 0 : _a.focus();
  }
  updateFocusTarget() {
    var _a;
    this.focusTarget = this.getSingleFocusable();
    for (const focusableElement of this.focusables) {
      const isFocusable = (_a = this.focusablesState.get(focusableElement)) !== null && _a !== void 0 ? _a : false;
      const newIsFocusable = this.focusTarget === focusableElement || this.isSuppressed(focusableElement);
      if (newIsFocusable !== isFocusable) {
        this.focusablesState.set(focusableElement, newIsFocusable);
        this.focusHandlers.get(focusableElement)(newIsFocusable);
      }
    }
  }
  isSuppressed(element) {
    if (!this.focusedCell) {
      return false;
    }
    return !element || defaultIsSuppressed(element);
  }
  isRegistered(element) {
    return !element || this.focusables.has(element);
  }
  updateFocusedCell(focusedElement) {
    var _a, _b, _c, _d, _e, _f;
    if (!focusedElement) {
      return;
    }
    const cellElement = getClosestCell(focusedElement);
    const rowElement = cellElement === null || cellElement === void 0 ? void 0 : cellElement.closest("tr");
    if (!cellElement || !rowElement) {
      return;
    }
    const colIndex = parseInt((_a = cellElement.getAttribute("aria-colindex")) !== null && _a !== void 0 ? _a : "");
    const rowIndex = parseInt((_b = rowElement.getAttribute("aria-rowindex")) !== null && _b !== void 0 ? _b : "");
    if (isNaN(colIndex) || isNaN(rowIndex)) {
      return;
    }
    const cellFocusables = this.getFocusablesFrom(cellElement);
    const elementIndex = cellFocusables.indexOf(focusedElement);
    const prevColIndex = (_d = (_c = this.focusedCell) === null || _c === void 0 ? void 0 : _c.colIndex) !== null && _d !== void 0 ? _d : -1;
    const prevElementIndex = (_f = (_e = this.focusedCell) === null || _e === void 0 ? void 0 : _e.elementIndex) !== null && _f !== void 0 ? _f : -1;
    this.focusedCell = {
      rowIndex,
      colIndex: this.keepUserIndex && prevColIndex !== -1 ? prevColIndex : colIndex,
      elementIndex: this.keepUserIndex && prevElementIndex !== -1 ? prevElementIndex : elementIndex,
      element: focusedElement
    };
  }
  getNextFocusable(from, delta) {
    var _a;
    const targetAriaRowIndex = from.rowIndex + delta.y;
    const targetRow = findTableRowByAriaRowIndex(this.table, targetAriaRowIndex, delta.y);
    if (!targetRow) {
      return null;
    }
    const cellElement = getClosestCell(from.element);
    const cellFocusables = cellElement ? this.getFocusablesFrom(cellElement) : [];
    const nextElementIndex = from.elementIndex + delta.x;
    const isValidDirection = !!delta.x;
    const isValidIndex = from.elementIndex !== -1 && 0 <= nextElementIndex && nextElementIndex < cellFocusables.length;
    const isTargetDifferent = from.element !== cellFocusables[nextElementIndex];
    if (isValidDirection && isValidIndex && isTargetDifferent) {
      return cellFocusables[nextElementIndex];
    }
    const targetAriaColIndex = from.colIndex + delta.x;
    const targetCell = findTableRowCellByAriaColIndex(targetRow, targetAriaColIndex, delta.x);
    if (!targetCell) {
      return null;
    }
    if (targetCell === cellElement && delta.x !== 0) {
      return null;
    }
    const targetCellFocusables = this.getFocusablesFrom(targetCell);
    let focusIndex = from.elementIndex;
    if (isFinite(delta.x) && delta.x > 0 || delta.x === -Infinity) {
      focusIndex = 0;
    }
    if (isFinite(delta.x) && delta.x < 0 || delta.x === Infinity) {
      focusIndex = targetCellFocusables.length - 1;
    }
    return (_a = targetCellFocusables[focusIndex]) !== null && _a !== void 0 ? _a : targetCell;
  }
  getSingleFocusable() {
    var _a;
    const cell = this.focusedCell;
    const firstTableCell = this.table.querySelector("td,th");
    let focusTarget = (_a = firstTableCell && this.getFocusablesFrom(firstTableCell)[0]) !== null && _a !== void 0 ? _a : firstTableCell;
    if (cell) {
      focusTarget = this.getNextFocusable(cell, { x: 0, y: 0 });
    }
    return focusTarget;
  }
  getFocusablesFrom(target) {
    return getAllFocusables(target).filter((el) => this.focusables.has(el) && !isElementDisabled(el));
  }
};

// node_modules/@cloudscape-design/components/table/header-cell/th-element.js
function TableThElement({ className, style, sortingStatus, sortingDisabled, focusedComponent, hidden, colIndex, columnId, stickyState, cellRef, tableRole, children }) {
  const stickyStyles = useStickyCellStyles({
    stickyColumns: stickyState,
    columnId,
    getClassName: (props) => getStickyClassNames(styles_css_default5, props)
  });
  const cellRefObject = (0, import_react16.useRef)(null);
  const mergedRef = useMergeRefs(stickyStyles.ref, cellRef, cellRefObject);
  const { tabIndex: cellTabIndex } = useSingleTabStopNavigation(cellRefObject);
  return import_react16.default.createElement("th", Object.assign({ "data-focus-id": `header-${String(columnId)}`, className: clsx_m_default(className, {
    [styles_css_default5["header-cell-fake-focus"]]: focusedComponent === `header-${String(columnId)}`,
    [styles_css_default5["header-cell-sortable"]]: sortingStatus,
    [styles_css_default5["header-cell-sorted"]]: sortingStatus === "ascending" || sortingStatus === "descending",
    [styles_css_default5["header-cell-disabled"]]: sortingDisabled,
    [styles_css_default5["header-cell-ascending"]]: sortingStatus === "ascending",
    [styles_css_default5["header-cell-descending"]]: sortingStatus === "descending",
    [styles_css_default5["header-cell-hidden"]]: hidden
  }, stickyStyles.className), style: Object.assign(Object.assign({}, style), stickyStyles.style), ref: mergedRef }, getTableColHeaderRoleProps({ tableRole, sortingStatus, colIndex }), { tabIndex: cellTabIndex }), children);
}

// node_modules/@cloudscape-design/components/table/header-cell/index.js
function TableHeaderCell({ className, style, tabIndex, column, activeSortingColumn, sortingDescending, sortingDisabled, wrapLines, focusedComponent, hidden, onClick, colIndex, updateColumn, resizableColumns, onResizeFinish, isEditable, columnId, stickyState, cellRef, tableRole, resizerRoleDescription, isExpandable }) {
  var _a;
  const i18n = useInternalI18n("table");
  const sortable = !!column.sortingComparator || !!column.sortingField;
  const sorted = !!activeSortingColumn && isSorted(column, activeSortingColumn);
  const sortingStatus = getSortingStatus(sortable, sorted, !!sortingDescending, !!sortingDisabled);
  const handleClick = () => onClick({
    sortingColumn: column,
    isDescending: sorted ? !sortingDescending : false
  });
  const handleKeyPress = ({ nativeEvent: e }) => {
    if (e.keyCode === KeyCode.enter || e.keyCode === KeyCode.space) {
      e.preventDefault();
      handleClick();
    }
  };
  const headerId = useUniqueId("table-header-");
  const clickableHeaderRef = (0, import_react17.useRef)(null);
  const { tabIndex: clickableHeaderTabIndex } = useSingleTabStopNavigation(clickableHeaderRef, { tabIndex });
  return import_react17.default.createElement(
    TableThElement,
    { className, style, cellRef, sortingStatus, sortingDisabled, focusedComponent, hidden, colIndex, columnId, stickyState, tableRole },
    import_react17.default.createElement(
      "div",
      Object.assign({ ref: clickableHeaderRef, "data-focus-id": `sorting-control-${String(columnId)}`, className: clsx_m_default(styles_css_default5["header-cell-content"], {
        [styles_css_default5["header-cell-fake-focus"]]: focusedComponent === `sorting-control-${String(columnId)}`,
        [styles_css_default5["header-cell-content-expandable"]]: isExpandable
      }), "aria-label": column.ariaLabel ? column.ariaLabel({
        sorted,
        descending: sorted && !!sortingDescending,
        disabled: !!sortingDisabled
      }) : void 0 }, sortingStatus && !sortingDisabled ? {
        onKeyPress: handleKeyPress,
        tabIndex: clickableHeaderTabIndex,
        role: "button",
        onClick: handleClick
      } : {}),
      import_react17.default.createElement(
        "div",
        { className: clsx_m_default(styles_css_default5["header-cell-text"], wrapLines && styles_css_default5["header-cell-text-wrap"]), id: headerId },
        column.header,
        isEditable && !isExpandable ? import_react17.default.createElement(
          "span",
          { className: styles_css_default5["edit-icon"], role: "img", "aria-label": i18n("columnDefinitions.editConfig.editIconAriaLabel", (_a = column.editConfig) === null || _a === void 0 ? void 0 : _a.editIconAriaLabel) },
          import_react17.default.createElement(internal_default, { name: "edit" })
        ) : null
      ),
      sortingStatus && import_react17.default.createElement(
        "span",
        { className: styles_css_default5["sorting-icon"] },
        import_react17.default.createElement(internal_default, { name: getSortingIconName(sortingStatus) })
      )
    ),
    resizableColumns ? import_react17.default.createElement(Resizer, { tabIndex, focusId: `resize-control-${String(columnId)}`, showFocusRing: focusedComponent === `resize-control-${String(columnId)}`, onWidthUpdate: (newWidth) => updateColumn(columnId, newWidth), onWidthUpdateCommit: onResizeFinish, ariaLabelledby: headerId, minWidth: typeof column.minWidth === "string" ? parseInt(column.minWidth) : column.minWidth, roleDescription: i18n("ariaLabels.resizerRoleDescription", resizerRoleDescription) }) : import_react17.default.createElement(Divider, { className: styles_css_default5["resize-divider"] })
  );
}

// node_modules/@cloudscape-design/components/table/thead.js
var Thead = import_react18.default.forwardRef(({ selectionType, getSelectAllProps, columnDefinitions, sortingColumn, sortingDisabled, sortingDescending, resizableColumns, variant, wrapLines, onFocusMove, onSortingChange, onResizeFinish, singleSelectionHeaderAriaLabel, stripedRows, sticky = false, hidden = false, stuck = false, stickyState, selectionColumnId: selectionColumnId2, focusedComponent, onFocusedComponentChange, tableRole, resizerRoleDescription, isExpandable }, outerRef) => {
  const isVisualRefresh = useVisualRefresh();
  const headerCellClass = clsx_m_default(styles_css_default5["header-cell"], styles_css_default5[`header-cell-variant-${variant}`], sticky && styles_css_default5["header-cell-sticky"], stuck && styles_css_default5["header-cell-stuck"], stripedRows && styles_css_default5["has-striped-rows"], isVisualRefresh && styles_css_default5["is-visual-refresh"]);
  const selectionCellClass = clsx_m_default(styles_css_default3["selection-control"], styles_css_default3["selection-control-header"], isVisualRefresh && styles_css_default3["is-visual-refresh"]);
  const { getColumnStyles, columnWidths, updateColumn, setCell } = useColumnWidths();
  return import_react18.default.createElement(
    "thead",
    { className: clsx_m_default(!hidden && styles_css_default3["thead-active"]) },
    import_react18.default.createElement(
      "tr",
      Object.assign({}, focusMarkers.all, { ref: outerRef, "aria-rowindex": 1 }, getTableHeaderRowRoleProps({ tableRole }), { onFocus: (event) => {
        var _a;
        const focusControlElement = findUpUntil(event.target, (element) => !!element.getAttribute("data-focus-id"));
        const focusId = (_a = focusControlElement === null || focusControlElement === void 0 ? void 0 : focusControlElement.getAttribute("data-focus-id")) !== null && _a !== void 0 ? _a : null;
        onFocusedComponentChange === null || onFocusedComponentChange === void 0 ? void 0 : onFocusedComponentChange(focusId);
      }, onBlur: () => onFocusedComponentChange === null || onFocusedComponentChange === void 0 ? void 0 : onFocusedComponentChange(null) }),
      selectionType ? import_react18.default.createElement(
        TableThElement,
        { className: clsx_m_default(headerCellClass, selectionCellClass, hidden && styles_css_default5["header-cell-hidden"]), hidden, tableRole, colIndex: 0, focusedComponent, columnId: selectionColumnId2, stickyState },
        selectionType === "multi" ? import_react18.default.createElement(SelectionControl, Object.assign({ onFocusDown: (event) => {
          onFocusMove(event.target, -1, 1);
        }, focusedComponent }, getSelectAllProps(), sticky ? { tabIndex: -1 } : {})) : import_react18.default.createElement(ScreenreaderOnly, null, singleSelectionHeaderAriaLabel),
        import_react18.default.createElement(Divider, { className: styles_css_default3["resize-divider"] })
      ) : null,
      columnDefinitions.map((column, colIndex) => {
        const columnId = getColumnKey(column, colIndex);
        return import_react18.default.createElement(TableHeaderCell, {
          key: columnId,
          style: getColumnStyles(sticky, columnId),
          className: headerCellClass,
          tabIndex: sticky ? -1 : 0,
          focusedComponent,
          column,
          activeSortingColumn: sortingColumn,
          sortingDescending,
          sortingDisabled,
          wrapLines,
          hidden,
          colIndex: selectionType ? colIndex + 1 : colIndex,
          columnId,
          updateColumn,
          onResizeFinish: () => onResizeFinish(columnWidths),
          resizableColumns,
          onClick: (detail) => fireNonCancelableEvent(onSortingChange, detail),
          isEditable: !!column.editConfig,
          stickyState,
          cellRef: (node) => setCell(sticky, columnId, node),
          tableRole,
          resizerRoleDescription,
          // Expandable option is only applicable to the first data column of the table.
          // When present, the header content receives extra padding to match the first offset in the data cells.
          isExpandable: colIndex === 0 && isExpandable
        });
      })
    )
  );
});
var thead_default = Thead;

// node_modules/@cloudscape-design/components/table/body-cell/styles.css.js
import "/home/a171157/personal-repos/deep-racer/community-contributions/deepracer-custom-console/new/node_modules/@cloudscape-design/components/table/body-cell/styles.scoped.css";
var styles_css_default7 = {
  "expandable-toggle-wrapper": "awsui_expandable-toggle-wrapper_c6tup_1ls9v_99",
  "body-cell": "awsui_body-cell_c6tup_1ls9v_107",
  "body-cell-content": "awsui_body-cell-content_c6tup_1ls9v_121",
  "body-cell-wrap": "awsui_body-cell-wrap_c6tup_1ls9v_124",
  "is-visual-refresh": "awsui_is-visual-refresh_c6tup_1ls9v_136",
  "has-striped-rows": "awsui_has-striped-rows_c6tup_1ls9v_148",
  "body-cell-expandable-level-1": "awsui_body-cell-expandable-level-1_c6tup_1ls9v_151",
  "body-cell-expandable-level-2": "awsui_body-cell-expandable-level-2_c6tup_1ls9v_154",
  "body-cell-expandable-level-3": "awsui_body-cell-expandable-level-3_c6tup_1ls9v_157",
  "body-cell-expandable-level-4": "awsui_body-cell-expandable-level-4_c6tup_1ls9v_160",
  "body-cell-expandable-level-5": "awsui_body-cell-expandable-level-5_c6tup_1ls9v_163",
  "body-cell-expandable-level-6": "awsui_body-cell-expandable-level-6_c6tup_1ls9v_166",
  "body-cell-expandable-level-7": "awsui_body-cell-expandable-level-7_c6tup_1ls9v_169",
  "body-cell-expandable-level-8": "awsui_body-cell-expandable-level-8_c6tup_1ls9v_172",
  "body-cell-expandable-level-9": "awsui_body-cell-expandable-level-9_c6tup_1ls9v_175",
  "body-cell-expandable-level-next": "awsui_body-cell-expandable-level-next_c6tup_1ls9v_178",
  "body-cell-edit-active": "awsui_body-cell-edit-active_c6tup_1ls9v_181",
  "body-cell-interactive": "awsui_body-cell-interactive_c6tup_1ls9v_181",
  "body-cell-editable": "awsui_body-cell-editable_c6tup_1ls9v_181",
  "has-striped-rows-sticky-cell-pad-left": "awsui_has-striped-rows-sticky-cell-pad-left_c6tup_1ls9v_247",
  "has-selection": "awsui_has-selection_c6tup_1ls9v_280",
  "body-cell-first-row": "awsui_body-cell-first-row_c6tup_1ls9v_316",
  "body-cell-last-row": "awsui_body-cell-last-row_c6tup_1ls9v_319",
  "body-cell-selected": "awsui_body-cell-selected_c6tup_1ls9v_319",
  "has-footer": "awsui_has-footer_c6tup_1ls9v_319",
  "body-cell-shaded": "awsui_body-cell-shaded_c6tup_1ls9v_329",
  "sticky-cell": "awsui_sticky-cell_c6tup_1ls9v_355",
  "sticky-cell-pad-left": "awsui_sticky-cell-pad-left_c6tup_1ls9v_363",
  "sticky-cell-last-right": "awsui_sticky-cell-last-right_c6tup_1ls9v_410",
  "sticky-cell-last-left": "awsui_sticky-cell-last-left_c6tup_1ls9v_414",
  "body-cell-next-selected": "awsui_body-cell-next-selected_c6tup_1ls9v_437",
  "body-cell-prev-selected": "awsui_body-cell-prev-selected_c6tup_1ls9v_441",
  "body-cell-editor-wrapper": "awsui_body-cell-editor-wrapper_c6tup_1ls9v_465",
  "body-cell-success": "awsui_body-cell-success_c6tup_1ls9v_472",
  "body-cell-editor": "awsui_body-cell-editor_c6tup_1ls9v_465",
  "body-cell-editor-disabled": "awsui_body-cell-editor-disabled_c6tup_1ls9v_499",
  "body-cell-editor-form": "awsui_body-cell-editor-form_c6tup_1ls9v_508",
  "body-cell-editor-row": "awsui_body-cell-editor-row_c6tup_1ls9v_518",
  "body-cell-editor-controls": "awsui_body-cell-editor-controls_c6tup_1ls9v_528",
  "body-cell-expandable": "awsui_body-cell-expandable_c6tup_1ls9v_151",
  "expandable-cell-content": "awsui_expandable-cell-content_c6tup_1ls9v_552",
  "body-cell-edit-disabled-popover": "awsui_body-cell-edit-disabled-popover_c6tup_1ls9v_600",
  "body-cell-has-success": "awsui_body-cell-has-success_c6tup_1ls9v_604"
};

// node_modules/@cloudscape-design/components/table/body-cell/index.js
var import_react29 = __toESM(require_react());

// node_modules/@cloudscape-design/components/table/body-cell/td-element.js
var import_react20 = __toESM(require_react());

// node_modules/@cloudscape-design/components/table/expandable-rows/expand-toggle-button.js
var import_react19 = __toESM(require_react());

// node_modules/@cloudscape-design/components/table/expandable-rows/styles.css.js
import "/home/a171157/personal-repos/deep-racer/community-contributions/deepracer-custom-console/new/node_modules/@cloudscape-design/components/table/expandable-rows/styles.scoped.css";
var styles_css_default8 = {
  "expand-toggle-icon": "awsui_expand-toggle-icon_1ss49_1izvf_99",
  "expand-toggle-icon-expanded": "awsui_expand-toggle-icon-expanded_1ss49_1izvf_120",
  "expand-toggle": "awsui_expand-toggle_1ss49_1izvf_99"
};

// node_modules/@cloudscape-design/components/table/expandable-rows/expand-toggle-button.js
function ExpandToggleButton({ isExpanded, onExpandableItemToggle, expandButtonLabel, collapseButtonLabel }) {
  const buttonRef = (0, import_react19.useRef)(null);
  const { tabIndex } = useSingleTabStopNavigation(buttonRef);
  return import_react19.default.createElement(
    "button",
    { ref: buttonRef, tabIndex, "aria-label": isExpanded ? collapseButtonLabel : expandButtonLabel, "aria-expanded": isExpanded, className: styles_css_default8["expand-toggle"], onClick: onExpandableItemToggle },
    import_react19.default.createElement(internal_default, { size: "small", name: "caret-down-filled", className: clsx_m_default(styles_css_default8["expand-toggle-icon"], isExpanded && styles_css_default8["expand-toggle-icon-expanded"]) })
  );
}

// node_modules/@cloudscape-design/components/table/body-cell/td-element.js
var TableTdElement = import_react20.default.forwardRef(({ className, style, children, wrapLines, isRowHeader, isFirstRow, isLastRow, isSelected, isNextSelected, isPrevSelected, nativeAttributes, onClick, onMouseEnter, onMouseLeave, isEvenRow, stripedRows, isVisualRefresh, hasSelection, hasFooter, columnId, colIndex, stickyState, tableRole, level, isExpandable, isExpanded, onExpandableItemToggle, expandButtonLabel, collapseButtonLabel }, ref) => {
  const Element = isRowHeader ? "th" : "td";
  nativeAttributes = Object.assign(Object.assign({}, nativeAttributes), getTableCellRoleProps({ tableRole, isRowHeader, colIndex }));
  const stickyStyles = useStickyCellStyles({
    stickyColumns: stickyState,
    columnId,
    getClassName: (props) => getStickyClassNames(styles_css_default7, props)
  });
  const cellRefObject = (0, import_react20.useRef)(null);
  const mergedRef = useMergeRefs(stickyStyles.ref, ref, cellRefObject);
  const { tabIndex: cellTabIndex } = useSingleTabStopNavigation(cellRefObject);
  return import_react20.default.createElement(
    Element,
    Object.assign({ style: Object.assign(Object.assign({}, style), stickyStyles.style), className: clsx_m_default(className, styles_css_default7["body-cell"], wrapLines && styles_css_default7["body-cell-wrap"], isFirstRow && styles_css_default7["body-cell-first-row"], isLastRow && styles_css_default7["body-cell-last-row"], isSelected && styles_css_default7["body-cell-selected"], isNextSelected && styles_css_default7["body-cell-next-selected"], isPrevSelected && styles_css_default7["body-cell-prev-selected"], !isEvenRow && stripedRows && styles_css_default7["body-cell-shaded"], stripedRows && styles_css_default7["has-striped-rows"], isVisualRefresh && styles_css_default7["is-visual-refresh"], hasSelection && styles_css_default7["has-selection"], hasFooter && styles_css_default7["has-footer"], level !== void 0 && styles_css_default7["body-cell-expandable"], level !== void 0 && styles_css_default7[`body-cell-expandable-level-${getLevelClassSuffix(level)}`], stickyStyles.className), onClick, onMouseEnter, onMouseLeave, ref: mergedRef }, nativeAttributes, { tabIndex: cellTabIndex }),
    level !== void 0 && isExpandable && import_react20.default.createElement(
      "div",
      { className: styles_css_default7["expandable-toggle-wrapper"] },
      import_react20.default.createElement(ExpandToggleButton, { isExpanded, onExpandableItemToggle, expandButtonLabel, collapseButtonLabel })
    ),
    import_react20.default.createElement("span", { className: styles_css_default7["body-cell-content"] }, children)
  );
});
function getLevelClassSuffix(level) {
  return 1 <= level && level <= 9 ? level : "next";
}

// node_modules/@cloudscape-design/components/table/body-cell/inline-editor.js
var import_react22 = __toESM(require_react());

// node_modules/@cloudscape-design/components/table/body-cell/click-away.js
var import_react21 = __toESM(require_react());
function useClickAway(onClick) {
  const awayRef = (0, import_react21.useRef)(null);
  const onClickStable = useStableCallback(onClick);
  (0, import_react21.useEffect)(() => {
    function handleClick(event) {
      if (!nodeBelongs(awayRef.current, event.target)) {
        onClickStable();
      }
    }
    document.addEventListener("click", handleClick, { capture: true });
    return () => document.removeEventListener("click", handleClick, { capture: true });
  }, [onClickStable]);
  return awayRef;
}

// node_modules/@cloudscape-design/components/table/body-cell/inline-editor.js
var noop = () => void 0;
function InlineEditor({ ariaLabels, item, column, onEditEnd, submitEdit, __onRender }) {
  var _a, _b, _c, _d;
  const [currentEditLoading, setCurrentEditLoading] = (0, import_react22.useState)(false);
  const [currentEditValue, setCurrentEditValue] = (0, import_react22.useState)();
  const i18n = useInternalI18n("table");
  const focusLockRef = (0, import_react22.useRef)(null);
  const cellContext = {
    currentValue: currentEditValue,
    setValue: setCurrentEditValue
  };
  function finishEdit({ cancelled = false, refocusCell = true } = {}) {
    if (!cancelled) {
      setCurrentEditValue(void 0);
    }
    onEditEnd({ cancelled, refocusCell });
  }
  function onSubmitClick(evt) {
    var _a2;
    return __awaiter(this, void 0, void 0, function* () {
      evt.preventDefault();
      if (currentEditValue === void 0) {
        finishEdit();
        return;
      }
      setCurrentEditLoading(true);
      try {
        yield submitEdit(item, column, currentEditValue);
        setCurrentEditLoading(false);
        finishEdit();
      } catch (e) {
        setCurrentEditLoading(false);
        (_a2 = focusLockRef.current) === null || _a2 === void 0 ? void 0 : _a2.focusFirst();
      }
    });
  }
  function onCancel({ reFocusEditedCell = true } = {}) {
    if (currentEditLoading) {
      return;
    }
    finishEdit({ cancelled: true, refocusCell: reFocusEditedCell });
  }
  function handleEscape(event) {
    if (event.key === "Escape") {
      onCancel();
    }
  }
  const clickAwayRef = useClickAway(() => onCancel({ reFocusEditedCell: false }));
  (0, import_react22.useEffect)(() => {
    if (__onRender) {
      const timer = setTimeout(__onRender, 1);
      return () => clearTimeout(timer);
    }
  }, [__onRender]);
  const { ariaLabel = void 0, validation = noop, errorIconAriaLabel, constraintText, editingCell } = column.editConfig;
  return import_react22.default.createElement(
    focus_lock_default,
    { restoreFocus: true, ref: focusLockRef },
    import_react22.default.createElement(
      "div",
      { role: "dialog", ref: clickAwayRef, "aria-label": (_a = ariaLabels === null || ariaLabels === void 0 ? void 0 : ariaLabels.activateEditLabel) === null || _a === void 0 ? void 0 : _a.call(ariaLabels, column, item), onKeyDown: handleEscape },
      import_react22.default.createElement(
        "form",
        { onSubmit: onSubmitClick, className: styles_css_default7["body-cell-editor-form"] },
        import_react22.default.createElement(
          InternalFormField,
          { stretch: true, label: ariaLabel, constraintText, __hideLabel: true, __disableGutters: true, i18nStrings: { errorIconAriaLabel }, errorText: validation(item, currentEditValue) },
          import_react22.default.createElement(
            "div",
            { className: styles_css_default7["body-cell-editor-row"] },
            editingCell(item, cellContext),
            import_react22.default.createElement(
              "span",
              { className: styles_css_default7["body-cell-editor-controls"] },
              import_react22.default.createElement(
                InternalSpaceBetween,
                { direction: "horizontal", size: "xxs" },
                !currentEditLoading ? import_react22.default.createElement(internal_default2, { ariaLabel: (_b = ariaLabels === null || ariaLabels === void 0 ? void 0 : ariaLabels.cancelEditLabel) === null || _b === void 0 ? void 0 : _b.call(ariaLabels, column), formAction: "none", iconName: "close", variant: "inline-icon", onClick: () => onCancel() }) : null,
                import_react22.default.createElement(internal_default2, { ariaLabel: (_c = ariaLabels === null || ariaLabels === void 0 ? void 0 : ariaLabels.submitEditLabel) === null || _c === void 0 ? void 0 : _c.call(ariaLabels, column), formAction: "submit", iconName: "check", variant: "inline-icon", loading: currentEditLoading })
              ),
              import_react22.default.createElement(live_region_default, null, currentEditLoading ? i18n("ariaLabels.submittingEditText", (_d = ariaLabels === null || ariaLabels === void 0 ? void 0 : ariaLabels.submittingEditText) === null || _d === void 0 ? void 0 : _d.call(ariaLabels, column)) : "")
            )
          )
        )
      )
    )
  );
}

// node_modules/@cloudscape-design/components/table/body-cell/disabled-inline-editor.js
var import_react28 = __toESM(require_react());

// node_modules/@cloudscape-design/components/button-dropdown/utils/use-hidden-description.js
var import_react23 = __toESM(require_react());
function useHiddenDescription(description) {
  const id = useUniqueId();
  return {
    targetProps: {
      "aria-describedby": description ? id : void 0
    },
    descriptionEl: description ? import_react23.default.createElement("span", { id, hidden: true }, description) : null
  };
}

// node_modules/@cloudscape-design/components/popover/container.js
var import_react25 = __toESM(require_react());

// node_modules/@cloudscape-design/components/popover/styles.css.js
import "/home/a171157/personal-repos/deep-racer/community-contributions/deepracer-custom-console/new/node_modules/@cloudscape-design/components/popover/styles.scoped.css";
var styles_css_default9 = {
  "arrow": "awsui_arrow_xjuzf_ov8et_197",
  "arrow-outer": "awsui_arrow-outer_xjuzf_ov8et_201",
  "arrow-inner": "awsui_arrow-inner_xjuzf_ov8et_201",
  "refresh": "awsui_refresh_xjuzf_ov8et_235",
  "arrow-position-right-top": "awsui_arrow-position-right-top_xjuzf_ov8et_245",
  "arrow-position-right-bottom": "awsui_arrow-position-right-bottom_xjuzf_ov8et_245",
  "arrow-position-left-top": "awsui_arrow-position-left-top_xjuzf_ov8et_248",
  "arrow-position-left-bottom": "awsui_arrow-position-left-bottom_xjuzf_ov8et_248",
  "arrow-position-top-center": "awsui_arrow-position-top-center_xjuzf_ov8et_251",
  "arrow-position-top-right": "awsui_arrow-position-top-right_xjuzf_ov8et_251",
  "arrow-position-top-left": "awsui_arrow-position-top-left_xjuzf_ov8et_251",
  "arrow-position-top-responsive": "awsui_arrow-position-top-responsive_xjuzf_ov8et_251",
  "arrow-position-bottom-center": "awsui_arrow-position-bottom-center_xjuzf_ov8et_254",
  "arrow-position-bottom-right": "awsui_arrow-position-bottom-right_xjuzf_ov8et_254",
  "arrow-position-bottom-left": "awsui_arrow-position-bottom-left_xjuzf_ov8et_254",
  "arrow-position-bottom-responsive": "awsui_arrow-position-bottom-responsive_xjuzf_ov8et_254",
  "body": "awsui_body_xjuzf_ov8et_356",
  "body-overflow-visible": "awsui_body-overflow-visible_xjuzf_ov8et_395",
  "has-dismiss": "awsui_has-dismiss_xjuzf_ov8et_399",
  "dismiss": "awsui_dismiss_xjuzf_ov8et_404",
  "dismiss-control": "awsui_dismiss-control_xjuzf_ov8et_412",
  "header-row": "awsui_header-row_xjuzf_ov8et_416",
  "header": "awsui_header_xjuzf_ov8et_416",
  "content": "awsui_content_xjuzf_ov8et_442",
  "content-overflow-visible": "awsui_content-overflow-visible_xjuzf_ov8et_450",
  "container": "awsui_container_xjuzf_ov8et_552",
  "container-body": "awsui_container-body_xjuzf_ov8et_560",
  "container-body-variant-annotation": "awsui_container-body-variant-annotation_xjuzf_ov8et_603",
  "container-body-size-small": "awsui_container-body-size-small_xjuzf_ov8et_608",
  "fixed-width": "awsui_fixed-width_xjuzf_ov8et_611",
  "container-body-size-medium": "awsui_container-body-size-medium_xjuzf_ov8et_615",
  "container-body-size-large": "awsui_container-body-size-large_xjuzf_ov8et_622",
  "container-arrow": "awsui_container-arrow_xjuzf_ov8et_634",
  "container-arrow-position-right-top": "awsui_container-arrow-position-right-top_xjuzf_ov8et_638",
  "container-arrow-position-right-bottom": "awsui_container-arrow-position-right-bottom_xjuzf_ov8et_638",
  "container-arrow-position-left-top": "awsui_container-arrow-position-left-top_xjuzf_ov8et_654",
  "container-arrow-position-left-bottom": "awsui_container-arrow-position-left-bottom_xjuzf_ov8et_654",
  "container-arrow-position-top-center": "awsui_container-arrow-position-top-center_xjuzf_ov8et_670",
  "container-arrow-position-top-right": "awsui_container-arrow-position-top-right_xjuzf_ov8et_670",
  "container-arrow-position-top-left": "awsui_container-arrow-position-top-left_xjuzf_ov8et_670",
  "container-arrow-position-top-responsive": "awsui_container-arrow-position-top-responsive_xjuzf_ov8et_670",
  "container-arrow-position-bottom-center": "awsui_container-arrow-position-bottom-center_xjuzf_ov8et_686",
  "container-arrow-position-bottom-right": "awsui_container-arrow-position-bottom-right_xjuzf_ov8et_690",
  "container-arrow-position-bottom-left": "awsui_container-arrow-position-bottom-left_xjuzf_ov8et_694",
  "awsui-motion-fade-in": "awsui_awsui-motion-fade-in_xjuzf_ov8et_1",
  "root": "awsui_root_xjuzf_ov8et_840",
  "trigger": "awsui_trigger_xjuzf_ov8et_876",
  "trigger-type-text": "awsui_trigger-type-text_xjuzf_ov8et_883",
  "trigger-inner-text": "awsui_trigger-inner-text_xjuzf_ov8et_918",
  "popover-inline-content": "awsui_popover-inline-content_xjuzf_ov8et_922"
};

// node_modules/@cloudscape-design/components/popover/use-popover-position.js
var import_react24 = __toESM(require_react());

// node_modules/@cloudscape-design/components/popover/utils/positions.js
var ARROW_OFFSET = 12;
var PRIORITY_MAPPING = {
  top: [
    "top-center",
    "top-right",
    "top-left",
    "bottom-center",
    "bottom-right",
    "bottom-left",
    "right-top",
    "right-bottom",
    "left-top",
    "left-bottom"
  ],
  bottom: [
    "bottom-center",
    "bottom-right",
    "bottom-left",
    "top-center",
    "top-right",
    "top-left",
    "right-top",
    "right-bottom",
    "left-top",
    "left-bottom"
  ],
  left: [
    "left-top",
    "left-bottom",
    "right-top",
    "right-bottom",
    "bottom-center",
    "top-center",
    "bottom-left",
    "top-left",
    "bottom-right",
    "top-right"
  ],
  right: [
    "right-top",
    "right-bottom",
    "left-top",
    "left-bottom",
    "bottom-center",
    "top-center",
    "bottom-right",
    "top-right",
    "bottom-left",
    "top-left"
  ]
};
var RECTANGLE_CALCULATIONS = {
  "top-center": ({ body, trigger, arrow }) => {
    return {
      insetBlockStart: trigger.insetBlockStart - body.blockSize - arrow.blockSize,
      insetInlineStart: trigger.insetInlineStart + trigger.inlineSize / 2 - body.inlineSize / 2,
      inlineSize: body.inlineSize,
      blockSize: body.blockSize
    };
  },
  "top-right": ({ body, trigger, arrow }) => {
    return {
      insetBlockStart: trigger.insetBlockStart - body.blockSize - arrow.blockSize,
      insetInlineStart: trigger.insetInlineStart + trigger.inlineSize / 2 - ARROW_OFFSET - arrow.inlineSize / 2,
      inlineSize: body.inlineSize,
      blockSize: body.blockSize
    };
  },
  "top-left": ({ body, trigger, arrow }) => {
    return {
      insetBlockStart: trigger.insetBlockStart - body.blockSize - arrow.blockSize,
      insetInlineStart: trigger.insetInlineStart + trigger.inlineSize / 2 + ARROW_OFFSET + arrow.inlineSize / 2 - body.inlineSize,
      inlineSize: body.inlineSize,
      blockSize: body.blockSize
    };
  },
  "bottom-center": ({ body, trigger, arrow }) => {
    return {
      insetBlockStart: trigger.insetBlockStart + trigger.blockSize + arrow.blockSize,
      insetInlineStart: trigger.insetInlineStart + trigger.inlineSize / 2 - body.inlineSize / 2,
      inlineSize: body.inlineSize,
      blockSize: body.blockSize
    };
  },
  "bottom-right": ({ body, trigger, arrow }) => {
    return {
      insetBlockStart: trigger.insetBlockStart + trigger.blockSize + arrow.blockSize,
      insetInlineStart: trigger.insetInlineStart + trigger.inlineSize / 2 - ARROW_OFFSET - arrow.inlineSize / 2,
      inlineSize: body.inlineSize,
      blockSize: body.blockSize
    };
  },
  "bottom-left": ({ body, trigger, arrow }) => {
    return {
      insetBlockStart: trigger.insetBlockStart + trigger.blockSize + arrow.blockSize,
      insetInlineStart: trigger.insetInlineStart + trigger.inlineSize / 2 + ARROW_OFFSET + arrow.inlineSize / 2 - body.inlineSize,
      inlineSize: body.inlineSize,
      blockSize: body.blockSize
    };
  },
  "right-top": ({ body, trigger, arrow }) => {
    return {
      insetBlockStart: trigger.insetBlockStart + trigger.blockSize / 2 - ARROW_OFFSET - arrow.blockSize,
      insetInlineStart: trigger.insetInlineStart + trigger.inlineSize + arrow.blockSize,
      inlineSize: body.inlineSize,
      blockSize: body.blockSize
    };
  },
  "right-bottom": ({ body, trigger, arrow }) => {
    return {
      insetBlockStart: trigger.insetBlockStart + trigger.blockSize / 2 - body.blockSize + ARROW_OFFSET + arrow.blockSize,
      insetInlineStart: trigger.insetInlineStart + trigger.inlineSize + arrow.blockSize,
      inlineSize: body.inlineSize,
      blockSize: body.blockSize
    };
  },
  "left-top": ({ body, trigger, arrow }) => {
    return {
      insetBlockStart: trigger.insetBlockStart + trigger.blockSize / 2 - ARROW_OFFSET - arrow.blockSize,
      insetInlineStart: trigger.insetInlineStart - body.inlineSize - arrow.blockSize,
      inlineSize: body.inlineSize,
      blockSize: body.blockSize
    };
  },
  "left-bottom": ({ body, trigger, arrow }) => {
    return {
      insetBlockStart: trigger.insetBlockStart + trigger.blockSize / 2 - body.blockSize + ARROW_OFFSET + arrow.blockSize,
      insetInlineStart: trigger.insetInlineStart - body.inlineSize - arrow.blockSize,
      inlineSize: body.inlineSize,
      blockSize: body.blockSize
    };
  }
};
function fitIntoContainer(inner, outer) {
  let { insetInlineStart, inlineSize, insetBlockStart, blockSize } = inner;
  if (insetInlineStart < outer.insetInlineStart) {
    inlineSize = insetInlineStart + inlineSize - outer.insetInlineStart;
    insetInlineStart = outer.insetInlineStart;
  } else if (insetInlineStart + inlineSize > outer.insetInlineStart + outer.inlineSize) {
    inlineSize = outer.insetInlineStart + outer.inlineSize - insetInlineStart;
  }
  if (insetBlockStart < outer.insetBlockStart) {
    blockSize = insetBlockStart + blockSize - outer.insetBlockStart;
    insetBlockStart = outer.insetBlockStart;
  } else if (insetBlockStart + blockSize > outer.insetBlockStart + outer.blockSize) {
    blockSize = outer.insetBlockStart + outer.blockSize - insetBlockStart;
  }
  return { insetInlineStart, inlineSize, insetBlockStart, blockSize };
}
function getTallestRect(rect1, rect2) {
  return rect1.blockSize >= rect2.blockSize ? rect1 : rect2;
}
function getIntersection(rectangles) {
  let boundingBox = null;
  for (const currentRect of rectangles) {
    if (!boundingBox) {
      boundingBox = currentRect;
      continue;
    }
    const insetInlineStart = Math.max(boundingBox.insetInlineStart, currentRect.insetInlineStart);
    const insetBlockStart = Math.max(boundingBox.insetBlockStart, currentRect.insetBlockStart);
    const insetInlineEnd = Math.min(boundingBox.insetInlineStart + boundingBox.inlineSize, currentRect.insetInlineStart + currentRect.inlineSize);
    const insetBlockEnd = Math.min(boundingBox.insetBlockStart + boundingBox.blockSize, currentRect.insetBlockStart + currentRect.blockSize);
    if (insetInlineEnd < insetInlineStart || insetBlockEnd < insetBlockStart) {
      return null;
    }
    boundingBox = {
      insetInlineStart,
      insetBlockStart,
      inlineSize: insetInlineEnd - insetInlineStart,
      blockSize: insetBlockEnd - insetBlockStart
    };
  }
  return boundingBox;
}
function calculatePosition({
  preferredPosition,
  fixedInternalPosition,
  trigger,
  arrow,
  body,
  container,
  viewport,
  // the popover is only bound by the viewport if it is rendered in a portal
  renderWithPortal,
  allowVerticalOverflow
}) {
  let bestOption = null;
  const preferredInternalPositions = fixedInternalPosition ? [fixedInternalPosition] : PRIORITY_MAPPING[preferredPosition];
  for (const internalPosition2 of preferredInternalPositions) {
    const rect2 = RECTANGLE_CALCULATIONS[internalPosition2]({ body, trigger, arrow });
    const visibleArea = renderWithPortal ? getIntersection([rect2, viewport]) : getIntersection([rect2, viewport, container]);
    const fitsWithoutOverflow = visibleArea && visibleArea.inlineSize === body.inlineSize && visibleArea.blockSize === body.blockSize;
    if (fitsWithoutOverflow) {
      return { internalPosition: internalPosition2, rect: rect2 };
    }
    const newOption = { rect: rect2, internalPosition: internalPosition2, visibleArea };
    bestOption = getBestOption(newOption, bestOption);
  }
  const internalPosition = (bestOption === null || bestOption === void 0 ? void 0 : bestOption.internalPosition) || "right-top";
  const rect = RECTANGLE_CALCULATIONS[internalPosition]({ body, trigger, arrow });
  const tallestBoundingContainer = getTallestRect(viewport, container);
  const boundingContainer = allowVerticalOverflow && isTopOrBottom(internalPosition) ? {
    insetBlockStart: tallestBoundingContainer.insetBlockStart,
    blockSize: tallestBoundingContainer.blockSize,
    insetInlineStart: viewport.insetInlineStart,
    inlineSize: viewport.inlineSize
  } : viewport;
  const optimizedRect = fitIntoContainer(rect, boundingContainer);
  const scrollable = optimizedRect.blockSize < rect.blockSize;
  return { internalPosition, rect: optimizedRect, scrollable };
}
function getBestOption(option1, option2) {
  if (!(option2 === null || option2 === void 0 ? void 0 : option2.visibleArea)) {
    return option1;
  }
  if (!option1.visibleArea) {
    return option2;
  }
  if (option1.visibleArea.inlineSize === option2.visibleArea.inlineSize) {
    return option1.visibleArea.blockSize > option2.visibleArea.blockSize ? option1 : option2;
  }
  return option1.visibleArea.inlineSize > option2.visibleArea.inlineSize ? option1 : option2;
}
function getOffsetDimensions(element) {
  return { offsetHeight: element.offsetHeight, offsetWidth: element.offsetWidth };
}
function getDimensions(element) {
  const computedStyle = getComputedStyle(element);
  return {
    inlineSize: parseFloat(computedStyle.inlineSize),
    blockSize: parseFloat(computedStyle.blockSize)
  };
}
function isTopOrBottom(internalPosition) {
  return ["top", "bottom"].includes(internalPosition.split("-")[0]);
}

// node_modules/@cloudscape-design/components/internal/direction.js
function isRtl(element) {
  return getComputedStyle(element).direction === "rtl";
}
function getScrollInlineStart(element) {
  return isRtl(element) ? Math.floor(element.scrollLeft) * -1 : Math.ceil(element.scrollLeft);
}
function getLogicalBoundingClientRect(element) {
  const boundingClientRect = element.getBoundingClientRect();
  const blockSize = boundingClientRect.height;
  const inlineSize = boundingClientRect.width;
  const insetBlockStart = boundingClientRect.top;
  const insetBlockEnd = boundingClientRect.bottom;
  const insetInlineStart = isRtl(element) ? document.documentElement.clientWidth - boundingClientRect.right : boundingClientRect.left;
  const insetInlineEnd = insetInlineStart + inlineSize;
  return {
    blockSize,
    inlineSize,
    insetBlockStart,
    insetBlockEnd,
    insetInlineStart,
    insetInlineEnd
  };
}

// node_modules/@cloudscape-design/components/popover/use-popover-position.js
function usePopoverPosition({ popoverRef, bodyRef, arrowRef, trackRef, contentRef, allowScrollToFit, allowVerticalOverflow, preferredPosition, renderWithPortal, keepPosition }) {
  const previousInternalPositionRef = (0, import_react24.useRef)(null);
  const [popoverStyle, setPopoverStyle] = (0, import_react24.useState)({});
  const [internalPosition, setInternalPosition] = (0, import_react24.useState)(null);
  const positionHandlerRef = (0, import_react24.useRef)(() => {
  });
  const updatePositionHandler = (0, import_react24.useCallback)((onContentResize = false) => {
    var _a;
    if (!trackRef.current || !popoverRef.current || !bodyRef.current || !contentRef.current || !arrowRef.current) {
      return;
    }
    const popover = popoverRef.current;
    const body = bodyRef.current;
    const arrow = arrowRef.current;
    const document2 = popover.ownerDocument;
    const track = trackRef.current;
    const { offsetWidth, offsetHeight } = getOffsetDimensions(popover);
    if (offsetWidth === 0 || offsetHeight === 0 || !nodeContains(document2.body, track)) {
      return;
    }
    const prevInsetBlockStart = popover.style.insetBlockStart;
    const prevInsetInlineStart = popover.style.insetInlineStart;
    popover.style.insetBlockStart = "0";
    popover.style.insetInlineStart = "0";
    body.style.maxBlockSize = "";
    body.style.overflowX = "";
    body.style.overflowY = "";
    const viewportRect = getViewportRect(document2.defaultView);
    const trackRect = getLogicalBoundingClientRect(track);
    const arrowRect = getDimensions(arrow);
    const containingBlock = getContainingBlock(popover);
    const containingBlockRect = containingBlock ? getLogicalBoundingClientRect(containingBlock) : viewportRect;
    const bodyBorderWidth = getBorderWidth(body);
    const contentRect = getLogicalBoundingClientRect(contentRef.current);
    const contentBoundingBox = {
      inlineSize: contentRect.inlineSize + 2 * bodyBorderWidth,
      blockSize: contentRect.blockSize + 2 * bodyBorderWidth
    };
    const shouldKeepPosition = keepPosition && onContentResize && !!previousInternalPositionRef.current;
    const fixedInternalPosition = (_a = shouldKeepPosition && previousInternalPositionRef.current) !== null && _a !== void 0 ? _a : void 0;
    const { scrollable, internalPosition: newInternalPosition, rect } = calculatePosition({
      preferredPosition,
      fixedInternalPosition,
      trigger: trackRect,
      arrow: arrowRect,
      body: contentBoundingBox,
      container: containingBlock ? containingBlockRect : getDocumentRect(document2),
      viewport: viewportRect,
      renderWithPortal,
      allowVerticalOverflow
    });
    const popoverOffset = toRelativePosition(rect, containingBlockRect);
    const trackRelativeOffset = toRelativePosition(popoverOffset, toRelativePosition(trackRect, containingBlockRect));
    popover.style.insetBlockStart = prevInsetBlockStart;
    popover.style.insetInlineStart = prevInsetInlineStart;
    if (scrollable) {
      body.style.maxBlockSize = rect.blockSize + "px";
      body.style.overflowX = "hidden";
      body.style.overflowY = "auto";
    }
    previousInternalPositionRef.current = newInternalPosition;
    setInternalPosition(newInternalPosition);
    const shouldScroll = allowScrollToFit && !shouldKeepPosition;
    const insetBlockStart = shouldScroll ? popoverOffset.insetBlockStart + calculateScroll(rect) : popoverOffset.insetBlockStart;
    setPopoverStyle({ insetBlockStart, insetInlineStart: popoverOffset.insetInlineStart });
    if (shouldScroll) {
      const scrollableParent = getFirstScrollableParent(popover);
      scrollRectangleIntoView(rect, scrollableParent);
    }
    positionHandlerRef.current = () => {
      const newTrackOffset = toRelativePosition(getLogicalBoundingClientRect(track), containingBlock ? getLogicalBoundingClientRect(containingBlock) : viewportRect);
      setPopoverStyle({
        insetBlockStart: newTrackOffset.insetBlockStart + trackRelativeOffset.insetBlockStart,
        insetInlineStart: newTrackOffset.insetInlineStart + trackRelativeOffset.insetInlineStart
      });
    };
  }, [
    trackRef,
    popoverRef,
    bodyRef,
    contentRef,
    arrowRef,
    keepPosition,
    allowScrollToFit,
    preferredPosition,
    renderWithPortal,
    allowVerticalOverflow
  ]);
  return { updatePositionHandler, popoverStyle, internalPosition, positionHandlerRef };
}
function getBorderWidth(element) {
  return parseInt(getComputedStyle(element).borderWidth) || 0;
}
function toRelativePosition(element, parent) {
  return {
    insetBlockStart: element.insetBlockStart - parent.insetBlockStart,
    insetInlineStart: element.insetInlineStart - parent.insetInlineStart
  };
}
function getViewportRect(window2) {
  return {
    insetBlockStart: 0,
    insetInlineStart: 0,
    inlineSize: window2.innerWidth,
    blockSize: window2.innerHeight
  };
}
function getDocumentRect(document2) {
  const { insetBlockStart, insetInlineStart } = getLogicalBoundingClientRect(document2.documentElement);
  return {
    insetBlockStart,
    insetInlineStart,
    inlineSize: document2.documentElement.scrollWidth,
    blockSize: document2.documentElement.scrollHeight
  };
}

// node_modules/@cloudscape-design/components/popover/container.js
function PopoverContainer({ position, trackRef, trackKey, arrow, children, zIndex, renderWithPortal, size, fixedWidth, variant, keepPosition, allowScrollToFit, allowVerticalOverflow }) {
  const bodyRef = (0, import_react25.useRef)(null);
  const contentRef = (0, import_react25.useRef)(null);
  const popoverRef = (0, import_react25.useRef)(null);
  const arrowRef = (0, import_react25.useRef)(null);
  const isRefresh = useVisualRefresh();
  const { updatePositionHandler, popoverStyle, internalPosition, positionHandlerRef } = usePopoverPosition({
    popoverRef,
    bodyRef,
    arrowRef,
    trackRef,
    contentRef,
    allowScrollToFit,
    allowVerticalOverflow,
    preferredPosition: position,
    renderWithPortal,
    keepPosition
  });
  (0, import_react25.useLayoutEffect)(() => {
    updatePositionHandler();
  }, [updatePositionHandler, trackKey]);
  useResizeObserver(contentRef, () => {
    updatePositionHandler(true);
  });
  (0, import_react25.useLayoutEffect)(() => {
    const onClick = (event) => {
      if (
        // Do not update position if keepPosition is true.
        keepPosition || // If the click was on the trigger, this will make the popover appear or disappear,
        // so no need to update its position either in this case.
        nodeContains(trackRef.current, event.target)
      ) {
        return;
      }
      requestAnimationFrame(() => {
        updatePositionHandler();
      });
    };
    const updatePositionOnResize = () => requestAnimationFrame(() => updatePositionHandler());
    const refreshPosition = () => requestAnimationFrame(() => positionHandlerRef.current());
    window.addEventListener("click", onClick);
    window.addEventListener("resize", updatePositionOnResize);
    window.addEventListener("scroll", refreshPosition, true);
    return () => {
      window.removeEventListener("click", onClick);
      window.removeEventListener("resize", updatePositionOnResize);
      window.removeEventListener("scroll", refreshPosition, true);
    };
  }, [keepPosition, positionHandlerRef, trackRef, updatePositionHandler]);
  return import_react25.default.createElement(
    "div",
    { ref: popoverRef, style: Object.assign(Object.assign({}, popoverStyle), { zIndex }), className: clsx_m_default(styles_css_default9.container, isRefresh && styles_css_default9.refresh) },
    import_react25.default.createElement("div", { ref: arrowRef, className: clsx_m_default(styles_css_default9[`container-arrow`], styles_css_default9[`container-arrow-position-${internalPosition}`]), "aria-hidden": true }, arrow(internalPosition)),
    import_react25.default.createElement(
      "div",
      { ref: bodyRef, className: clsx_m_default(styles_css_default9["container-body"], styles_css_default9[`container-body-size-${size}`], {
        [styles_css_default9["fixed-width"]]: fixedWidth,
        [styles_css_default9[`container-body-variant-${variant}`]]: variant
      }) },
      import_react25.default.createElement("div", { ref: contentRef }, children)
    )
  );
}

// node_modules/@cloudscape-design/components/popover/body.js
var import_react26 = __toESM(require_react());
function PopoverBody({ dismissButton: showDismissButton, dismissAriaLabel, header, children, onDismiss, variant, overflowVisible, className, ariaLabelledby }) {
  const i18n = useInternalI18n("popover");
  const labelledById = useUniqueId("awsui-popover-");
  const dismissButtonFocused = (0, import_react26.useRef)(false);
  const dismissButtonRef = (0, import_react26.useRef)(null);
  const onKeyDown = (0, import_react26.useCallback)((event) => {
    if (event.keyCode === KeyCode.escape) {
      event.stopPropagation();
      onDismiss === null || onDismiss === void 0 ? void 0 : onDismiss();
    }
  }, [onDismiss]);
  (0, import_react26.useEffect)(() => {
    var _a;
    if (showDismissButton && !dismissButtonFocused.current) {
      (_a = dismissButtonRef.current) === null || _a === void 0 ? void 0 : _a.focus({ preventScroll: true });
    }
    dismissButtonFocused.current = showDismissButton;
  }, [showDismissButton]);
  const dismissButton = (showDismissButton !== null && showDismissButton !== void 0 ? showDismissButton : null) && import_react26.default.createElement(
    "div",
    { className: styles_css_default9.dismiss },
    import_react26.default.createElement(InternalButton, { variant: "icon", formAction: "none", iconName: "close", className: styles_css_default9["dismiss-control"], ariaLabel: i18n("dismissAriaLabel", dismissAriaLabel), onClick: () => onDismiss === null || onDismiss === void 0 ? void 0 : onDismiss(), ref: dismissButtonRef })
  );
  const isDialog = showDismissButton;
  const shouldTrapFocus = showDismissButton && variant !== "annotation";
  const dialogProps = isDialog ? {
    role: "dialog",
    "aria-modal": shouldTrapFocus ? true : void 0,
    "aria-labelledby": ariaLabelledby !== null && ariaLabelledby !== void 0 ? ariaLabelledby : header ? labelledById : void 0
  } : {};
  return import_react26.default.createElement(
    "div",
    Object.assign({ className: clsx_m_default(styles_css_default9.body, className, {
      [styles_css_default9["body-overflow-visible"]]: overflowVisible === "both"
    }), onKeyDown }, dialogProps),
    import_react26.default.createElement(
      focus_lock_default,
      { disabled: !shouldTrapFocus, autoFocus: false },
      header && import_react26.default.createElement(
        "div",
        { className: clsx_m_default(styles_css_default9["header-row"], showDismissButton && styles_css_default9["has-dismiss"]) },
        dismissButton,
        import_react26.default.createElement(
          "div",
          { className: styles_css_default9.header, id: labelledById },
          import_react26.default.createElement("h2", null, header)
        )
      ),
      import_react26.default.createElement(
        "div",
        { className: !header && showDismissButton ? styles_css_default9["has-dismiss"] : void 0 },
        !header && dismissButton,
        import_react26.default.createElement("div", { className: clsx_m_default(styles_css_default9.content, { [styles_css_default9["content-overflow-visible"]]: !!overflowVisible }) }, children)
      )
    )
  );
}

// node_modules/@cloudscape-design/components/internal/hooks/use-portal-mode-classes/index.js
function usePortalModeClasses(ref) {
  const colorMode = useCurrentMode(ref);
  const densityMode = useDensityMode(ref);
  const context = useVisualContext(ref);
  const visualRefresh = useVisualRefresh();
  return clsx_m_default({
    "awsui-polaris-dark-mode awsui-dark-mode": colorMode === "dark",
    "awsui-polaris-compact-mode awsui-compact-mode": densityMode === "compact",
    "awsui-visual-refresh": visualRefresh,
    [`awsui-context-${context}`]: context
  });
}

// node_modules/@cloudscape-design/components/popover/arrow.js
var import_react27 = __toESM(require_react());
var Arrow = (props) => {
  const isVisualRefresh = useVisualRefresh();
  return import_react27.default.createElement(
    "div",
    { className: clsx_m_default(styles_css_default9.arrow, props.position && styles_css_default9[`arrow-position-${props.position}`]) },
    import_react27.default.createElement("div", { className: styles_css_default9["arrow-outer"] }),
    import_react27.default.createElement("div", { className: clsx_m_default(styles_css_default9["arrow-inner"], isVisualRefresh && styles_css_default9.refresh) })
  );
};
var arrow_default = import_react27.default.memo(Arrow);

// node_modules/@cloudscape-design/components/table/body-cell/disabled-inline-editor.js
function DisabledInlineEditor(_a) {
  var _b;
  var { className, item, column, ariaLabels, isEditing, onEditStart, onEditEnd, editDisabledReason, isVisualRefresh, interactiveCell = true } = _a, rest = __rest(_a, ["className", "item", "column", "ariaLabels", "isEditing", "onEditStart", "onEditEnd", "editDisabledReason", "isVisualRefresh", "interactiveCell"]);
  const clickAwayRef = useClickAway(() => {
    if (isEditing) {
      onEditEnd(true);
    }
  });
  const [hasHover, setHasHover] = (0, import_react28.useState)(false);
  const [hasFocus, setHasFocus] = (0, import_react28.useState)(false);
  const showIcon = hasHover || hasFocus || isEditing || !interactiveCell;
  const iconRef = (0, import_react28.useRef)(null);
  const buttonRef = (0, import_react28.useRef)(null);
  const portalRef = (0, import_react28.useRef)(null);
  function handleEscape(event) {
    if (event.key === "Escape") {
      onEditEnd(true);
    }
  }
  const onClick = () => {
    var _a2;
    onEditStart();
    (_a2 = buttonRef.current) === null || _a2 === void 0 ? void 0 : _a2.focus();
  };
  const { targetProps, descriptionEl } = useHiddenDescription(editDisabledReason);
  const portalClasses = usePortalModeClasses(portalRef);
  const { tabIndex } = useSingleTabStopNavigation(buttonRef);
  return import_react28.default.createElement(
    TableTdElement,
    Object.assign({}, rest, { nativeAttributes: { "data-inline-editing-active": isEditing.toString() }, className: clsx_m_default(className, styles_css_default7["body-cell-editable"], interactiveCell && styles_css_default7["body-cell-interactive"], isEditing && styles_css_default7["body-cell-edit-disabled-popover"], isVisualRefresh && styles_css_default7["is-visual-refresh"]), onClick: interactiveCell && !isEditing ? onClick : void 0, onMouseEnter: () => setHasHover(true), onMouseLeave: () => setHasHover(false), ref: clickAwayRef }),
    column.cell(item),
    import_react28.default.createElement(
      "div",
      { className: styles_css_default7["body-cell-editor-wrapper"] },
      import_react28.default.createElement(
        "button",
        Object.assign({ ref: buttonRef, tabIndex, className: clsx_m_default(styles_css_default7["body-cell-editor"], styles_css_default7["body-cell-editor-disabled"]), "aria-label": (_b = ariaLabels === null || ariaLabels === void 0 ? void 0 : ariaLabels.activateEditLabel) === null || _b === void 0 ? void 0 : _b.call(ariaLabels, column, item), "aria-haspopup": "dialog", "aria-disabled": "true", onClick: !interactiveCell && !isEditing ? onClick : void 0, onFocus: () => setHasFocus(true), onBlur: () => setHasFocus(false), onKeyDown: handleEscape }, targetProps),
        showIcon && import_react28.default.createElement(internal_default, { name: "lock-private", variant: "normal", __internalRootRef: iconRef }),
        descriptionEl
      )
    ),
    isEditing && import_react28.default.createElement(
      "span",
      { ref: portalRef },
      import_react28.default.createElement(
        Portal,
        null,
        import_react28.default.createElement(
          "span",
          { className: portalClasses },
          import_react28.default.createElement(
            PopoverContainer,
            { size: "medium", fixedWidth: false, position: "top", trackRef: iconRef, arrow: (position) => import_react28.default.createElement(arrow_default, { position }), renderWithPortal: true, zIndex: 2e3 },
            import_react28.default.createElement(
              PopoverBody,
              { dismissButton: false, dismissAriaLabel: void 0, header: null, onDismiss: () => {
              }, overflowVisible: "both" },
              import_react28.default.createElement("span", { "aria-live": "polite" }, editDisabledReason)
            )
          )
        )
      )
    )
  );
}

// node_modules/@cloudscape-design/components/table/body-cell/index.js
var submitHandlerFallback = () => {
  throw new Error("The function `handleSubmit` is required for editable columns");
};
function TableCellEditable(_a) {
  var _b, _c, _d;
  var { className, item, column, isEditing, onEditStart, onEditEnd, submitEdit, ariaLabels, isVisualRefresh, successfulEdit = false, interactiveCell = true } = _a, rest = __rest(_a, ["className", "item", "column", "isEditing", "onEditStart", "onEditEnd", "submitEdit", "ariaLabels", "isVisualRefresh", "successfulEdit", "interactiveCell"]);
  const i18n = useInternalI18n("table");
  const editActivateRef = (0, import_react29.useRef)(null);
  const tdNativeAttributes = {
    "data-inline-editing-active": isEditing.toString()
  };
  const isFocusMoveNeededRef = (0, import_react29.useRef)(false);
  (0, import_react29.useEffect)(() => {
    if (!isEditing && editActivateRef.current && isFocusMoveNeededRef.current) {
      isFocusMoveNeededRef.current = false;
      editActivateRef.current.focus();
    }
  }, [isEditing]);
  const [hasHover, setHasHover] = (0, import_react29.useState)(false);
  const [hasFocus, setHasFocus] = (0, import_react29.useState)(false);
  const showIcon = hasHover || hasFocus || !interactiveCell;
  const prevSuccessfulEdit = usePrevious(successfulEdit);
  const prevHasFocus = usePrevious(hasFocus);
  const [showSuccessIcon, setShowSuccessIcon] = (0, import_react29.useState)(false);
  (0, import_react29.useEffect)(() => {
    if (successfulEdit && prevSuccessfulEdit && !hasFocus && prevHasFocus) {
      setShowSuccessIcon(false);
    }
    if (successfulEdit && !prevSuccessfulEdit) {
      setShowSuccessIcon(true);
    }
  }, [hasFocus, successfulEdit, prevHasFocus, prevSuccessfulEdit]);
  const { tabIndex: editActivateTabIndex } = useSingleTabStopNavigation(editActivateRef);
  return import_react29.default.createElement(TableTdElement, Object.assign({}, rest, { nativeAttributes: tdNativeAttributes, className: clsx_m_default(className, styles_css_default7["body-cell-editable"], interactiveCell && styles_css_default7["body-cell-interactive"], isEditing && styles_css_default7["body-cell-edit-active"], showSuccessIcon && showIcon && styles_css_default7["body-cell-has-success"], isVisualRefresh && styles_css_default7["is-visual-refresh"]), onClick: interactiveCell && !isEditing ? onEditStart : void 0, onMouseEnter: () => setHasHover(true), onMouseLeave: () => setHasHover(false) }), isEditing ? import_react29.default.createElement(InlineEditor, { ariaLabels, column, item, onEditEnd: (options) => {
    setShowSuccessIcon(false);
    isFocusMoveNeededRef.current = options.refocusCell;
    onEditEnd(options.cancelled);
  }, submitEdit: submitEdit !== null && submitEdit !== void 0 ? submitEdit : submitHandlerFallback }) : import_react29.default.createElement(
    import_react29.default.Fragment,
    null,
    column.cell(item),
    showSuccessIcon && showIcon && import_react29.default.createElement(
      import_react29.default.Fragment,
      null,
      import_react29.default.createElement(
        "span",
        { className: styles_css_default7["body-cell-success"], "aria-label": (_b = ariaLabels === null || ariaLabels === void 0 ? void 0 : ariaLabels.successfulEditLabel) === null || _b === void 0 ? void 0 : _b.call(ariaLabels, column), role: "img", onMouseDown: (e) => {
          e.preventDefault();
        } },
        import_react29.default.createElement(internal_default, { name: "status-positive", variant: "success" })
      ),
      import_react29.default.createElement(live_region_default, null, i18n("ariaLabels.successfulEditLabel", (_c = ariaLabels === null || ariaLabels === void 0 ? void 0 : ariaLabels.successfulEditLabel) === null || _c === void 0 ? void 0 : _c.call(ariaLabels, column)))
    ),
    import_react29.default.createElement(
      "div",
      { className: styles_css_default7["body-cell-editor-wrapper"] },
      import_react29.default.createElement("button", { className: styles_css_default7["body-cell-editor"], "aria-label": (_d = ariaLabels === null || ariaLabels === void 0 ? void 0 : ariaLabels.activateEditLabel) === null || _d === void 0 ? void 0 : _d.call(ariaLabels, column, item), ref: editActivateRef, onClick: !interactiveCell && !isEditing ? onEditStart : void 0, onFocus: () => setHasFocus(true), onBlur: () => setHasFocus(false), tabIndex: editActivateTabIndex }, showIcon && import_react29.default.createElement(internal_default, { name: "edit" }))
    )
  ));
}
function TableBodyCell(_a) {
  var _b, _c;
  var { isEditable } = _a, rest = __rest(_a, ["isEditable"]);
  const isExpandableColumnCell = rest.level !== void 0;
  const editDisabledReason = (_c = (_b = rest.column.editConfig) === null || _b === void 0 ? void 0 : _b.disabledReason) === null || _c === void 0 ? void 0 : _c.call(_b, rest.item);
  if (editDisabledReason && !isExpandableColumnCell) {
    return import_react29.default.createElement(DisabledInlineEditor, Object.assign({ editDisabledReason }, rest));
  }
  if ((isEditable || rest.isEditing) && !isExpandableColumnCell) {
    return import_react29.default.createElement(TableCellEditable, Object.assign({}, rest));
  }
  const { column, item } = rest;
  return import_react29.default.createElement(TableTdElement, Object.assign({}, rest), column.cell(item));
}

// node_modules/@cloudscape-design/components/table/use-row-events.js
function useRowEvents({ onRowClick, onRowContextMenu }) {
  const onRowClickHandler = (rowIndex, item, event) => {
    const tableCell = findUpUntil2(event.target, (element) => element.tagName.toLowerCase() === "td");
    if (!tableCell || !tableCell.classList.contains(styles_css_default3["selection-control"])) {
      const details = { rowIndex, item };
      fireNonCancelableEvent(onRowClick, details);
    }
  };
  const onRowContextMenuHandler = (rowIndex, item, event) => {
    const details = {
      rowIndex,
      item,
      clientX: event.clientX,
      clientY: event.clientY
    };
    fireCancelableEvent(onRowContextMenu, details, event);
  };
  return {
    onRowClickHandler: onRowClick && onRowClickHandler,
    onRowContextMenuHandler: onRowContextMenu && onRowContextMenuHandler
  };
}

// node_modules/@cloudscape-design/components/internal/hooks/use-scroll-sync/index.js
var import_react30 = __toESM(require_react());
function useScrollSync(refs, disabled = !supportsStickyPosition()) {
  const activeElement = (0, import_react30.useRef)(null);
  const onScroll = (event) => {
    const targetElement = event.currentTarget;
    if (targetElement && (activeElement.current === null || activeElement.current === targetElement)) {
      requestAnimationFrame(() => {
        activeElement.current = targetElement;
        refs.forEach((ref) => {
          const element = ref.current;
          if (element && element !== targetElement) {
            element.scrollLeft = targetElement.scrollLeft;
          }
        });
        requestAnimationFrame(() => {
          activeElement.current = null;
        });
      });
    }
  };
  return !disabled ? onScroll : void 0;
}

// node_modules/@cloudscape-design/components/table/sticky-header.js
var import_react32 = __toESM(require_react());

// node_modules/@cloudscape-design/components/table/use-sticky-header.js
var import_react31 = __toESM(require_react());

// node_modules/@cloudscape-design/components/table/sticky-scrolling.js
function stickyScrolling(containerRef, stickyRef) {
  const scrollToTop = () => {
    if (!containerRef.current || !stickyRef.current) {
      return;
    }
    const scrollingOffset = calculateScrollingOffset(containerRef.current, stickyRef.current);
    if (scrollingOffset > 0) {
      scrollUpBy(scrollingOffset, containerRef.current);
    }
  };
  const scrollToItem = (item) => {
    if (!item || !containerRef.current || !stickyRef.current) {
      return;
    }
    const stickyBottom = stickyRef.current.getBoundingClientRect().bottom;
    const scrollingOffset = stickyBottom - item.getBoundingClientRect().top;
    if (scrollingOffset > 0) {
      scrollUpBy(scrollingOffset, containerRef.current);
    }
  };
  return {
    scrollToTop,
    scrollToItem
  };
}
function calculateScrollingOffset(container, sticky) {
  const stickyRect = sticky.getBoundingClientRect();
  const containerRect = container.getBoundingClientRect();
  return stickyRect.top - containerRect.top;
}
function scrollUpBy(amount, container) {
  const parent = getOverflowParents(container);
  if (parent.length) {
    parent[0].scrollTop -= amount;
  } else {
    window.scrollTo({ top: window.pageYOffset - amount });
  }
}

// node_modules/@cloudscape-design/components/table/use-sticky-header.js
var useStickyHeader2 = (tableRef, theadRef, secondaryTheadRef, secondaryTableRef, tableWrapperRef) => {
  const isMobile = useMobile();
  const syncColumnHeaderWidths = (0, import_react31.useCallback)(() => {
    if (tableRef.current && theadRef.current && secondaryTheadRef.current && secondaryTableRef.current && tableWrapperRef.current) {
      secondaryTableRef.current.style.width = `${tableRef.current.offsetWidth}px`;
      tableWrapperRef.current.style.marginTop = `-${theadRef.current.offsetHeight}px`;
    }
  }, [theadRef, secondaryTheadRef, secondaryTableRef, tableWrapperRef, tableRef]);
  (0, import_react31.useLayoutEffect)(() => {
    syncColumnHeaderWidths();
  });
  useResizeObserver(theadRef, syncColumnHeaderWidths);
  const scrollToTop = () => {
    if (!isMobile && theadRef.current && secondaryTheadRef.current && tableWrapperRef.current) {
      const scrollDist = calculateScrollingOffset(theadRef.current, secondaryTheadRef.current);
      if (scrollDist > 0) {
        scrollUpBy(scrollDist, tableWrapperRef.current);
      }
    }
  };
  const { scrollToItem } = stickyScrolling(tableWrapperRef, secondaryTheadRef);
  const scrollToRow = (itemNode) => {
    if (!isMobile) {
      scrollToItem(itemNode);
    }
  };
  return { scrollToRow, scrollToTop };
};

// node_modules/@cloudscape-design/components/table/sticky-header.js
var sticky_header_default = (0, import_react32.forwardRef)(StickyHeader);
function StickyHeader({ variant, theadProps, wrapperRef, theadRef, secondaryWrapperRef, onScroll, tableRef, tableHasHeader, contentDensity, tableRole }, ref) {
  const secondaryTheadRef = (0, import_react32.useRef)(null);
  const secondaryTableRef = (0, import_react32.useRef)(null);
  const { isStuck } = (0, import_react32.useContext)(StickyHeaderContext);
  const [focusedComponent, setFocusedComponent] = (0, import_react32.useState)(null);
  const { scrollToRow, scrollToTop } = useStickyHeader2(tableRef, theadRef, secondaryTheadRef, secondaryTableRef, wrapperRef);
  (0, import_react32.useImperativeHandle)(ref, () => ({
    scrollToTop,
    scrollToRow,
    setFocus: setFocusedComponent
  }));
  return import_react32.default.createElement(
    "div",
    {
      className: clsx_m_default(styles_css_default3["header-secondary"], styles_css_default3[`variant-${variant}`], {
        [styles_css_default3.stuck]: isStuck,
        [styles_css_default3["table-has-header"]]: tableHasHeader
      }),
      "aria-hidden": true,
      // Prevents receiving focus in Firefox. Focus on the overflowing table is sufficient
      // to scroll the table horizontally
      tabIndex: -1,
      ref: secondaryWrapperRef,
      onScroll
    },
    import_react32.default.createElement(
      "table",
      Object.assign({ className: clsx_m_default(styles_css_default3.table, styles_css_default3["table-layout-fixed"], contentDensity === "compact" && getVisualContextClassname("compact-table")), ref: secondaryTableRef }, getTableRoleProps({ tableRole })),
      import_react32.default.createElement(thead_default, Object.assign({ ref: secondaryTheadRef, sticky: true, stuck: isStuck, focusedComponent }, theadProps))
    )
  );
}

// node_modules/@cloudscape-design/components/internal/hooks/use-mouse-down-target.js
var import_react33 = __toESM(require_react());
var useEventListenersSingleton = createSingletonHandler((setTarget) => {
  function handleMouseDown(event) {
    setTarget(event.target);
  }
  function handleKeyDown() {
    setTarget(null);
  }
  window.addEventListener("mousedown", handleMouseDown);
  window.addEventListener("keydown", handleKeyDown);
  return () => {
    window.removeEventListener("mousedown", handleMouseDown);
    window.removeEventListener("keydown", handleKeyDown);
  };
});
function useMouseDownTarget() {
  const mouseDownTargetRef = (0, import_react33.useRef)(null);
  useEventListenersSingleton((target) => {
    mouseDownTargetRef.current = target;
  });
  return () => mouseDownTargetRef.current;
}

// node_modules/@cloudscape-design/components/table/use-table-focus-navigation.js
var import_react34 = __toESM(require_react());
function iterateTableCells(table, func) {
  table.querySelectorAll("tr").forEach((row, rowIndex) => {
    row.querySelectorAll("td").forEach((cell, cellIndex) => {
      func(cell, rowIndex, cellIndex);
    });
  });
}
function useTableFocusNavigation({ enableKeyboardNavigation, selectionType, tableRoot, columnDefinitions, numRows }) {
  const focusableColumns = (0, import_react34.useMemo)(() => {
    const cols = columnDefinitions.map((column) => !!column.editConfig);
    if (selectionType) {
      cols.unshift(false);
    }
    return cols;
  }, [columnDefinitions, selectionType]);
  const maxColumnIndex = focusableColumns.length - 1;
  const minColumnIndex = selectionType ? 1 : 0;
  const focusCell = (0, import_react34.useCallback)((rowIndex, columnIndex) => {
    if (tableRoot === null || tableRoot === void 0 ? void 0 : tableRoot.current) {
      iterateTableCells(tableRoot.current, (cell, rIndex, cIndex) => {
        var _a;
        if (rIndex === rowIndex && cIndex === columnIndex) {
          const editButton = cell.querySelector("button:last-child");
          if (editButton) {
            (_a = editButton.focus) === null || _a === void 0 ? void 0 : _a.call(editButton);
            scrollElementIntoView(editButton);
          }
        }
      });
    }
  }, [tableRoot]);
  const shiftFocus = (0, import_react34.useCallback)((vertical, horizontal) => {
    var _a;
    const focusedCell = (_a = tableRoot.current) === null || _a === void 0 ? void 0 : _a.querySelector("td:focus-within");
    if (!focusedCell) {
      return;
    }
    const columnIndex = focusedCell.cellIndex;
    const rowIndex = focusedCell.parentElement.rowIndex;
    let newRowIndex = rowIndex;
    let newColumnIndex = columnIndex;
    if (vertical !== 0) {
      newRowIndex = Math.min(numRows, Math.max(rowIndex + vertical, 0));
    }
    if (horizontal !== 0) {
      while (newColumnIndex <= maxColumnIndex && newColumnIndex >= minColumnIndex) {
        newColumnIndex += horizontal;
        if (focusableColumns[newColumnIndex]) {
          break;
        }
      }
    }
    if ((rowIndex !== newRowIndex || columnIndex !== newColumnIndex) && tableRoot.current) {
      focusCell(newRowIndex, newColumnIndex);
    }
  }, [focusCell, focusableColumns, maxColumnIndex, minColumnIndex, numRows, tableRoot]);
  const handleArrowKeyEvents = (0, import_react34.useCallback)((event) => {
    var _a, _b;
    const abort = !!((_a = tableRoot.current) === null || _a === void 0 ? void 0 : _a.querySelector('[data-inline-editing-active = "true"]')) || !((_b = document.activeElement) === null || _b === void 0 ? void 0 : _b.closest("[data-inline-editing-active]"));
    if (abort) {
      return;
    }
    switch (event.key) {
      case "ArrowUp":
        event.preventDefault();
        shiftFocus(-1, 0);
        break;
      case "ArrowDown":
        event.preventDefault();
        shiftFocus(1, 0);
        break;
      case "ArrowLeft":
        event.preventDefault();
        shiftFocus(0, -1);
        break;
      case "ArrowRight":
        event.preventDefault();
        shiftFocus(0, 1);
        break;
      default:
        return;
    }
  }, [shiftFocus, tableRoot]);
  (0, import_react34.useEffect)(() => {
    if (!tableRoot.current || enableKeyboardNavigation) {
      return;
    }
    const tableElement = tableRoot.current;
    tableRoot.current.addEventListener("keydown", handleArrowKeyEvents);
    return () => tableElement && tableElement.removeEventListener("keydown", handleArrowKeyEvents);
  }, [enableKeyboardNavigation, focusableColumns, handleArrowKeyEvents, tableRoot]);
}
var use_table_focus_navigation_default = useTableFocusNavigation;

// node_modules/@cloudscape-design/components/table/sticky-scrollbar/sticky-scrollbar.js
var import_react36 = __toESM(require_react());

// node_modules/@cloudscape-design/components/table/sticky-scrollbar/use-sticky-scrollbar.js
var import_react35 = __toESM(require_react());

// node_modules/@cloudscape-design/components/table/sticky-scrollbar/styles.css.js
import "/home/a171157/personal-repos/deep-racer/community-contributions/deepracer-custom-console/new/node_modules/@cloudscape-design/components/table/sticky-scrollbar/styles.scoped.css";
var styles_css_default10 = {
  "sticky-scrollbar": "awsui_sticky-scrollbar_faqt8_xxk3x_99",
  "sticky-scrollbar-content": "awsui_sticky-scrollbar-content_faqt8_xxk3x_108",
  "sticky-scrollbar-visible": "awsui_sticky-scrollbar-visible_faqt8_xxk3x_111",
  "sticky-scrollbar-native-invisible": "awsui_sticky-scrollbar-native-invisible_faqt8_xxk3x_114",
  "sticky-scrollbar-offset": "awsui_sticky-scrollbar-offset_faqt8_xxk3x_117",
  "is-visual-refresh": "awsui_is-visual-refresh_faqt8_xxk3x_120"
};

// node_modules/@cloudscape-design/components/table/sticky-scrollbar/use-sticky-scrollbar.js
var updatePosition = (tableEl, wrapperEl, scrollbarEl, scrollbarContentEl, hasContainingBlock, consideredFooterHeight) => {
  if (!tableEl || !scrollbarEl || !wrapperEl) {
    return;
  }
  const { width: tableWidth } = tableEl.getBoundingClientRect();
  const { width: wrapperWidth } = wrapperEl.getBoundingClientRect();
  const scrollbarHeight = browserScrollbarSize().height;
  const areaIsScrollable = tableWidth > wrapperWidth;
  if (!areaIsScrollable) {
    scrollbarEl.classList.remove(styles_css_default10["sticky-scrollbar-visible"]);
  } else {
    if (!scrollbarEl.classList.contains(styles_css_default10["sticky-scrollbar-visible"])) {
      requestAnimationFrame(() => {
        scrollbarEl.scrollLeft = wrapperEl.scrollLeft;
      });
    }
    scrollbarEl.classList.add(styles_css_default10["sticky-scrollbar-visible"]);
    if (!scrollbarHeight) {
      scrollbarEl.classList.add(styles_css_default10["sticky-scrollbar-native-invisible"]);
    }
  }
  if (scrollbarHeight && scrollbarEl && scrollbarContentEl) {
    scrollbarEl.style.height = `${scrollbarHeight}px`;
    scrollbarContentEl.style.height = `${scrollbarHeight}px`;
  }
  if (tableEl && wrapperEl && scrollbarContentEl && scrollbarEl) {
    const wrapperElRect = wrapperEl.getBoundingClientRect();
    const tableElRect = tableEl.getBoundingClientRect();
    scrollbarEl.style.width = `${wrapperElRect.width}px`;
    scrollbarContentEl.style.width = `${tableElRect.width}px`;
    scrollbarEl.style.bottom = hasContainingBlock ? "0px" : `${consideredFooterHeight}px`;
  }
};
function useStickyScrollbar(scrollbarRef, scrollbarContentRef, tableRef, wrapperRef, footerHeight, offsetScrollbar) {
  const [hasContainingBlock, setHasContainingBlock] = (0, import_react35.useState)(false);
  const [hasOverflowParent, setHasOverflowParent] = (0, import_react35.useState)(false);
  const consideredFooterHeight = hasContainingBlock || hasOverflowParent ? 0 : footerHeight;
  const wrapperEl = wrapperRef.current;
  (0, import_react35.useEffect)(() => {
    if (wrapperEl && supportsStickyPosition()) {
      setHasContainingBlock(!!getContainingBlock(wrapperEl));
      setHasOverflowParent(!!getOverflowParents(wrapperEl)[0]);
    }
  }, [wrapperEl]);
  (0, import_react35.useEffect)(() => {
    if (supportsStickyPosition() && wrapperRef.current && tableRef.current) {
      const observer = new ResizeObserver(() => {
        if (scrollbarContentRef.current) {
          updatePosition(tableRef.current, wrapperRef.current, scrollbarRef.current, scrollbarContentRef.current, hasContainingBlock, consideredFooterHeight);
        }
      });
      observer.observe(wrapperRef.current);
      observer.observe(tableRef.current);
      return () => {
        observer.disconnect();
      };
    }
  }, [
    scrollbarContentRef,
    scrollbarRef,
    tableRef,
    wrapperRef,
    consideredFooterHeight,
    hasContainingBlock,
    offsetScrollbar
  ]);
  (0, import_react35.useEffect)(() => {
    if (supportsStickyPosition()) {
      const resizeHandler = () => {
        updatePosition(tableRef.current, wrapperRef.current, scrollbarRef.current, scrollbarContentRef.current, hasContainingBlock, consideredFooterHeight);
      };
      resizeHandler();
      window.addEventListener("resize", resizeHandler);
      return () => {
        window.removeEventListener("resize", resizeHandler);
      };
    }
  }, [tableRef, wrapperRef, scrollbarRef, scrollbarContentRef, hasContainingBlock, consideredFooterHeight]);
}

// node_modules/@cloudscape-design/components/table/sticky-scrollbar/sticky-scrollbar.js
var sticky_scrollbar_default = (0, import_react36.forwardRef)(StickyScrollbar);
function StickyScrollbar({ wrapperRef, tableRef, onScroll, hasStickyColumns }, ref) {
  const isVisualRefresh = useVisualRefresh();
  const scrollbarRef = import_react36.default.useRef(null);
  const scrollbarContentRef = import_react36.default.useRef(null);
  const mergedRef = useMergeRefs(ref, scrollbarRef);
  const offsetScrollbar = hasStickyColumns || browserScrollbarSize().height === 0;
  const { stickyOffsetBottom } = useAppLayoutContext();
  useStickyScrollbar(scrollbarRef, scrollbarContentRef, tableRef, wrapperRef, stickyOffsetBottom, offsetScrollbar);
  return import_react36.default.createElement(
    "div",
    { ref: mergedRef, className: clsx_m_default(styles_css_default10["sticky-scrollbar"], offsetScrollbar && styles_css_default10["sticky-scrollbar-offset"], isVisualRefresh && styles_css_default10["is-visual-refresh"]), onScroll },
    import_react36.default.createElement("div", { ref: scrollbarContentRef, className: styles_css_default10["sticky-scrollbar-content"] })
  );
}

// node_modules/@cloudscape-design/components/table/use-cell-editing.js
var import_react37 = __toESM(require_react());
function useCellEditing({ onCancel, onSubmit }) {
  const [currentEditCell, setCurrentEditCell] = (0, import_react37.useState)(null);
  const [lastSuccessfulEditCell, setLastSuccessfulEditCell] = (0, import_react37.useState)(null);
  const [currentEditLoading, setCurrentEditLoading] = (0, import_react37.useState)(false);
  const startEdit = (cellId) => {
    setLastSuccessfulEditCell(null);
    setCurrentEditCell(cellId);
  };
  const cancelEdit = (0, import_react37.useCallback)(() => setCurrentEditCell(null), []);
  const completeEdit = (cellId, editCancelled) => {
    const eventCancelled = fireCancelableEvent(onCancel, {});
    if (!eventCancelled) {
      setCurrentEditCell(null);
      if (!editCancelled) {
        setLastSuccessfulEditCell(cellId);
      }
    }
  };
  const checkEditing = ({ rowIndex, colIndex }) => rowIndex === (currentEditCell === null || currentEditCell === void 0 ? void 0 : currentEditCell.rowIndex) && colIndex === currentEditCell.colIndex;
  const checkLastSuccessfulEdit = ({ rowIndex, colIndex }) => rowIndex === (lastSuccessfulEditCell === null || lastSuccessfulEditCell === void 0 ? void 0 : lastSuccessfulEditCell.rowIndex) && colIndex === lastSuccessfulEditCell.colIndex;
  const submitEdit = onSubmit ? (...args) => __awaiter(this, void 0, void 0, function* () {
    setCurrentEditLoading(true);
    try {
      yield onSubmit(...args);
    } finally {
      setCurrentEditLoading(false);
    }
  }) : void 0;
  return {
    isLoading: currentEditLoading,
    startEdit,
    cancelEdit,
    checkEditing,
    checkLastSuccessfulEdit,
    completeEdit,
    submitEdit
  };
}

// node_modules/@cloudscape-design/components/table/no-data-cell.js
var import_react39 = __toESM(require_react());

// node_modules/@cloudscape-design/components/status-indicator/internal.js
var import_react38 = __toESM(require_react());

// node_modules/@cloudscape-design/components/status-indicator/styles.css.js
import "/home/a171157/personal-repos/deep-racer/community-contributions/deepracer-custom-console/new/node_modules/@cloudscape-design/components/status-indicator/styles.scoped.css";
var styles_css_default11 = {
  "icon-shake": "awsui_icon-shake_1cbgc_azp03_103",
  "awsui-motion-shake-horizontally": "awsui_awsui-motion-shake-horizontally_1cbgc_azp03_1",
  "container-fade-in": "awsui_container-fade-in_1cbgc_azp03_131",
  "awsui-motion-fade-in-0": "awsui_awsui-motion-fade-in-0_1cbgc_azp03_1",
  "root": "awsui_root_1cbgc_azp03_153",
  "status-error": "awsui_status-error_1cbgc_azp03_162",
  "status-warning": "awsui_status-warning_1cbgc_azp03_165",
  "status-success": "awsui_status-success_1cbgc_azp03_168",
  "status-info": "awsui_status-info_1cbgc_azp03_171",
  "status-stopped": "awsui_status-stopped_1cbgc_azp03_174",
  "status-pending": "awsui_status-pending_1cbgc_azp03_177",
  "status-in-progress": "awsui_status-in-progress_1cbgc_azp03_180",
  "status-loading": "awsui_status-loading_1cbgc_azp03_183",
  "color-override-red": "awsui_color-override-red_1cbgc_azp03_186",
  "color-override-grey": "awsui_color-override-grey_1cbgc_azp03_189",
  "color-override-blue": "awsui_color-override-blue_1cbgc_azp03_192",
  "color-override-green": "awsui_color-override-green_1cbgc_azp03_195",
  "color-override-yellow": "awsui_color-override-yellow_1cbgc_azp03_198",
  "container": "awsui_container_1cbgc_azp03_131",
  "display-inline": "awsui_display-inline_1cbgc_azp03_202",
  "icon": "awsui_icon_1cbgc_azp03_103",
  "display-inline-block": "awsui_display-inline-block_1cbgc_azp03_210",
  "overflow-ellipsis": "awsui_overflow-ellipsis_1cbgc_azp03_219"
};

// node_modules/@cloudscape-design/components/status-indicator/internal.js
var typeToIcon = (size) => ({
  error: import_react38.default.createElement(internal_default, { name: "status-negative", size }),
  warning: import_react38.default.createElement(internal_default, { name: "status-warning", size }),
  success: import_react38.default.createElement(internal_default, { name: "status-positive", size }),
  info: import_react38.default.createElement(internal_default, { name: "status-info", size }),
  stopped: import_react38.default.createElement(internal_default, { name: "status-stopped", size }),
  pending: import_react38.default.createElement(internal_default, { name: "status-pending", size }),
  "in-progress": import_react38.default.createElement(internal_default, { name: "status-in-progress", size }),
  loading: import_react38.default.createElement(InternalSpinner, null)
});
function StatusIndicator(_a) {
  var { type, children, iconAriaLabel, colorOverride, wrapText = true, __animate = false, __internalRootRef, __size = "normal", __display = "inline-block" } = _a, rest = __rest(_a, ["type", "children", "iconAriaLabel", "colorOverride", "wrapText", "__animate", "__internalRootRef", "__size", "__display"]);
  const baseProps = getBaseProps(rest);
  return import_react38.default.createElement(
    "span",
    Object.assign({}, baseProps, { className: clsx_m_default(styles_css_default11.root, styles_css_default11[`status-${type}`], {
      [styles_css_default11[`color-override-${colorOverride}`]]: colorOverride
    }, baseProps.className), ref: __internalRootRef }),
    import_react38.default.createElement(
      "span",
      { className: clsx_m_default(styles_css_default11.container, styles_css_default11[`display-${__display}`], wrapText === false && styles_css_default11["overflow-ellipsis"], __animate && styles_css_default11["container-fade-in"]) },
      import_react38.default.createElement(
        "span",
        { className: clsx_m_default(styles_css_default11.icon, __animate && styles_css_default11["icon-shake"]), "aria-label": iconAriaLabel, role: iconAriaLabel ? "img" : void 0 },
        typeToIcon(__size)[type],
        __display === "inline" && import_react38.default.createElement(import_react38.default.Fragment, null, "Â ")
      ),
      children
    )
  );
}

// node_modules/@cloudscape-design/components/table/no-data-cell.js
function NoDataCell({ totalColumnsCount, hasFooter, loading, loadingText, empty, tableRef, containerRef }) {
  const cellContentRef = (0, import_react39.useRef)(null);
  useResizeObserver(containerRef, ({ contentBoxWidth: containerWidth }) => {
    if (tableRef.current && cellContentRef.current && supportsStickyPosition()) {
      const tablePaddingLeft = parseFloat(getComputedStyle(tableRef.current).paddingLeft) || 0;
      const tablePaddingRight = parseFloat(getComputedStyle(tableRef.current).paddingRight) || 0;
      const contentWidth = containerWidth + tablePaddingLeft + tablePaddingRight;
      cellContentRef.current.style.width = Math.floor(contentWidth) + "px";
    }
  });
  return import_react39.default.createElement(
    "td",
    { colSpan: totalColumnsCount, className: clsx_m_default(styles_css_default3["cell-merged"], hasFooter && styles_css_default3["has-footer"]) },
    import_react39.default.createElement("div", { ref: cellContentRef, className: styles_css_default3["cell-merged-content"], "data-awsui-table-suppress-navigation": true }, loading ? import_react39.default.createElement(
      StatusIndicator,
      { type: "loading", className: styles_css_default3.loading, wrapText: true },
      import_react39.default.createElement(live_region_default, { visible: true }, loadingText)
    ) : import_react39.default.createElement("div", { className: styles_css_default3.empty }, empty))
  );
}

// node_modules/@cloudscape-design/components/table/expandable-rows/expandable-rows-utils.js
function useExpandableTableProps({ items, expandableRows, trackBy, ariaLabels }) {
  var _a;
  const i18n = useInternalI18n("table");
  const isExpandable = !!expandableRows;
  const expandedSet = new ItemSet(trackBy, (_a = expandableRows === null || expandableRows === void 0 ? void 0 : expandableRows.expandedItems) !== null && _a !== void 0 ? _a : []);
  let allItems = items;
  const itemToPlacement = /* @__PURE__ */ new Map();
  const getItemLevel = (item) => {
    var _a2, _b;
    return (_b = (_a2 = itemToPlacement.get(item)) === null || _a2 === void 0 ? void 0 : _a2.level) !== null && _b !== void 0 ? _b : 0;
  };
  if (isExpandable) {
    const visibleItems = new Array();
    const traverse = (item, placement) => {
      itemToPlacement.set(item, placement);
      visibleItems.push(item);
      if (expandedSet.has(item)) {
        const children = expandableRows.getItemChildren(item);
        expandableRows.getItemChildren(item).forEach((child, index) => traverse(child, { level: placement.level + 1, setSize: children.length, posInSet: index + 1 }));
      }
    };
    items.forEach((item, index) => traverse(item, { level: 1, setSize: items.length, posInSet: index + 1 }));
    for (let index = 0; index < visibleItems.length; index++) {
      const item = visibleItems[index];
      if (expandedSet.has(item)) {
        let insertionIndex = index + 1;
        for (insertionIndex; insertionIndex < visibleItems.length; insertionIndex++) {
          const insertionItem = visibleItems[insertionIndex];
          if (getItemLevel(item) >= getItemLevel(insertionItem)) {
            break;
          }
        }
        insertionIndex--;
      }
    }
    allItems = visibleItems;
  }
  const getExpandableItemProps = (item) => {
    var _a2, _b, _c, _d;
    const { level, setSize, posInSet } = (_a2 = itemToPlacement.get(item)) !== null && _a2 !== void 0 ? _a2 : { level: 1, setSize: 1, posInSet: 1 };
    return {
      level,
      setSize,
      posInSet,
      isExpandable: (_b = expandableRows === null || expandableRows === void 0 ? void 0 : expandableRows.isItemExpandable(item)) !== null && _b !== void 0 ? _b : true,
      isExpanded: expandedSet.has(item),
      onExpandableItemToggle: () => fireNonCancelableEvent(expandableRows === null || expandableRows === void 0 ? void 0 : expandableRows.onExpandableItemToggle, { item, expanded: !expandedSet.has(item) }),
      expandButtonLabel: i18n("ariaLabels.expandButtonLabel", (_c = ariaLabels === null || ariaLabels === void 0 ? void 0 : ariaLabels.expandButtonLabel) === null || _c === void 0 ? void 0 : _c.call(ariaLabels, item)),
      collapseButtonLabel: i18n("ariaLabels.collapseButtonLabel", (_d = ariaLabels === null || ariaLabels === void 0 ? void 0 : ariaLabels.collapseButtonLabel) === null || _d === void 0 ? void 0 : _d.call(ariaLabels, item))
    };
  };
  return { isExpandable, allItems, getExpandableItemProps };
}

// node_modules/@cloudscape-design/components/table/internal.js
var GRID_NAVIGATION_PAGE_SIZE = 10;
var SELECTION_COLUMN_WIDTH = 54;
var selectionColumnId = Symbol("selection-column-id");
var InternalTableAsSubstep = import_react40.default.forwardRef((props, ref) => {
  const { funnelSubStepProps } = useFunnelSubStep();
  const tableProps = Object.assign(Object.assign({}, props), { __funnelSubStepProps: funnelSubStepProps });
  return import_react40.default.createElement(InternalTable, Object.assign({}, tableProps, { ref }));
});
var InternalTable = import_react40.default.forwardRef((_a, ref) => {
  var _b, _c, _d, _e, _f;
  var { header, footer, empty, filter, pagination, preferences, items, columnDefinitions, trackBy, loading, loadingText, selectionType, selectedItems, isItemDisabled, ariaLabels, onSelectionChange, onSortingChange, sortingColumn, sortingDescending, sortingDisabled, visibleColumns, stickyHeader, stickyHeaderVerticalOffset, onRowClick, onRowContextMenu, wrapLines, stripedRows, contentDensity, submitEdit, onEditCancel, resizableColumns, onColumnWidthsChange, variant, __internalRootRef, totalItemsCount, firstIndex, renderAriaLive, stickyColumns, columnDisplay, enableKeyboardNavigation, expandableRows, __funnelSubStepProps } = _a, rest = __rest(_a, ["header", "footer", "empty", "filter", "pagination", "preferences", "items", "columnDefinitions", "trackBy", "loading", "loadingText", "selectionType", "selectedItems", "isItemDisabled", "ariaLabels", "onSelectionChange", "onSortingChange", "sortingColumn", "sortingDescending", "sortingDisabled", "visibleColumns", "stickyHeader", "stickyHeaderVerticalOffset", "onRowClick", "onRowContextMenu", "wrapLines", "stripedRows", "contentDensity", "submitEdit", "onEditCancel", "resizableColumns", "onColumnWidthsChange", "variant", "__internalRootRef", "totalItemsCount", "firstIndex", "renderAriaLive", "stickyColumns", "columnDisplay", "enableKeyboardNavigation", "expandableRows", "__funnelSubStepProps"]);
  if (expandableRows && enableKeyboardNavigation === void 0) {
    enableKeyboardNavigation = true;
  }
  const baseProps = getBaseProps(rest);
  stickyHeader = stickyHeader && supportsStickyPosition();
  const isMobile = useMobile();
  const { isExpandable, allItems, getExpandableItemProps } = useExpandableTableProps({
    items,
    expandableRows,
    trackBy,
    ariaLabels
  });
  const [containerWidth, wrapperMeasureRef] = useContainerQuery((rect) => rect.contentBoxWidth);
  const wrapperMeasureRefObject = (0, import_react40.useRef)(null);
  const wrapperMeasureMergedRef = useMergeRefs(wrapperMeasureRef, wrapperMeasureRefObject);
  const [tableWidth, tableMeasureRef] = useContainerQuery((rect) => rect.contentBoxWidth);
  const tableRefObject = (0, import_react40.useRef)(null);
  const secondaryWrapperRef = import_react40.default.useRef(null);
  const theadRef = (0, import_react40.useRef)(null);
  const stickyHeaderRef = import_react40.default.useRef(null);
  const scrollbarRef = import_react40.default.useRef(null);
  const _g = useCellEditing({ onCancel: onEditCancel, onSubmit: submitEdit }), { cancelEdit } = _g, cellEditing = __rest(_g, ["cancelEdit"]);
  usePerformanceMarks("table", true, tableRefObject, () => {
    var _a2, _b2, _c2, _d2;
    const headerText = (_c2 = (_b2 = (_a2 = toolsHeaderWrapper.current) === null || _a2 === void 0 ? void 0 : _a2.querySelector(`.${styles_css_default["heading-text"]}`)) === null || _b2 === void 0 ? void 0 : _b2.innerText) !== null && _c2 !== void 0 ? _c2 : (_d2 = toolsHeaderWrapper.current) === null || _d2 === void 0 ? void 0 : _d2.innerText;
    return {
      loading: loading !== null && loading !== void 0 ? loading : false,
      header: headerText
    };
  }, [loading]);
  (0, import_react40.useImperativeHandle)(ref, () => {
    var _a2;
    return {
      scrollToTop: ((_a2 = stickyHeaderRef.current) === null || _a2 === void 0 ? void 0 : _a2.scrollToTop) || (() => void 0),
      cancelEdit
    };
  }, [cancelEdit]);
  const wrapperRefObject = (0, import_react40.useRef)(null);
  const handleScroll = useScrollSync([wrapperRefObject, scrollbarRef, secondaryWrapperRef]);
  const { moveFocusDown, moveFocusUp, moveFocus } = useSelectionFocusMove(selectionType, allItems.length);
  const { onRowClickHandler, onRowContextMenuHandler } = useRowEvents({ onRowClick, onRowContextMenu });
  const visibleColumnDefinitions = getVisibleColumnDefinitions({
    columnDefinitions,
    columnDisplay,
    visibleColumns
  });
  const { isItemSelected, getSelectAllProps, getItemSelectionProps, updateShiftToggle } = useSelection({
    items: allItems,
    trackBy,
    selectedItems,
    selectionType,
    isItemDisabled,
    onSelectionChange,
    ariaLabels,
    loading
  });
  if (isDevelopment) {
    if (resizableColumns) {
      checkColumnWidths(columnDefinitions);
    }
    if (sortingColumn === null || sortingColumn === void 0 ? void 0 : sortingColumn.sortingComparator) {
      checkSortingState(columnDefinitions, sortingColumn.sortingComparator);
    }
  }
  const isVisualRefresh = useVisualRefresh();
  const computedVariant = isVisualRefresh ? variant : ["embedded", "full-page"].indexOf(variant) > -1 ? "container" : variant;
  const hasHeader = !!(header || filter || pagination || preferences);
  const hasSelection = !!selectionType;
  const hasFooterPagination = isMobile && variant === "full-page" && !!pagination;
  const hasFooter = !!footer || hasFooterPagination;
  const headerIdRef = (0, import_react40.useRef)(void 0);
  const isLabelledByHeader = !(ariaLabels === null || ariaLabels === void 0 ? void 0 : ariaLabels.tableLabel) && !!header;
  const setHeaderRef = (0, import_react40.useCallback)((id) => {
    headerIdRef.current = id;
  }, []);
  const visibleColumnWidthsWithSelection = [];
  const visibleColumnIdsWithSelection = [];
  if (hasSelection) {
    visibleColumnWidthsWithSelection.push({ id: selectionColumnId, width: SELECTION_COLUMN_WIDTH });
    visibleColumnIdsWithSelection.push(selectionColumnId);
  }
  for (let columnIndex = 0; columnIndex < visibleColumnDefinitions.length; columnIndex++) {
    const columnId = getColumnKey(visibleColumnDefinitions[columnIndex], columnIndex);
    visibleColumnWidthsWithSelection.push(Object.assign(Object.assign({}, visibleColumnDefinitions[columnIndex]), { id: columnId }));
    visibleColumnIdsWithSelection.push(columnId);
  }
  const stickyState = useStickyColumns({
    visibleColumns: visibleColumnIdsWithSelection,
    stickyColumnsFirst: ((_b = stickyColumns === null || stickyColumns === void 0 ? void 0 : stickyColumns.first) !== null && _b !== void 0 ? _b : 0) + ((stickyColumns === null || stickyColumns === void 0 ? void 0 : stickyColumns.first) && hasSelection ? 1 : 0),
    stickyColumnsLast: (stickyColumns === null || stickyColumns === void 0 ? void 0 : stickyColumns.last) || 0
  });
  const hasStickyColumns = !!(((_c = stickyColumns === null || stickyColumns === void 0 ? void 0 : stickyColumns.first) !== null && _c !== void 0 ? _c : 0) + ((_d = stickyColumns === null || stickyColumns === void 0 ? void 0 : stickyColumns.last) !== null && _d !== void 0 ? _d : 0) > 0);
  const hasEditableCells = !!columnDefinitions.find((col) => col.editConfig);
  let tableRole = "table";
  if (isExpandable) {
    tableRole = "treegrid";
  } else if (enableKeyboardNavigation) {
    tableRole = "grid";
  } else if (hasEditableCells) {
    tableRole = "grid-default";
  }
  const theadProps = {
    selectionType,
    getSelectAllProps,
    columnDefinitions: visibleColumnDefinitions,
    variant: computedVariant,
    wrapLines,
    resizableColumns,
    sortingColumn,
    sortingDisabled,
    sortingDescending,
    onSortingChange,
    onFocusMove: moveFocus,
    onResizeFinish(newWidth) {
      const widthsDetail = columnDefinitions.map((column, index) => newWidth.get(getColumnKey(column, index)) || column.width || DEFAULT_COLUMN_WIDTH);
      const widthsChanged = widthsDetail.some((width, index) => columnDefinitions[index].width !== width);
      if (widthsChanged) {
        fireNonCancelableEvent(onColumnWidthsChange, { widths: widthsDetail });
      }
    },
    singleSelectionHeaderAriaLabel: ariaLabels === null || ariaLabels === void 0 ? void 0 : ariaLabels.selectionGroupLabel,
    resizerRoleDescription: ariaLabels === null || ariaLabels === void 0 ? void 0 : ariaLabels.resizerRoleDescription,
    stripedRows,
    stickyState,
    selectionColumnId,
    tableRole,
    isExpandable
  };
  const wrapperRef = useMergeRefs(wrapperRefObject, stickyState.refs.wrapper);
  const tableRef = useMergeRefs(tableMeasureRef, tableRefObject, stickyState.refs.table);
  const wrapperProps = getTableWrapperRoleProps({
    tableRole,
    isScrollable: !!(tableWidth && containerWidth && tableWidth > containerWidth),
    ariaLabel: ariaLabels === null || ariaLabels === void 0 ? void 0 : ariaLabels.tableLabel
  });
  const getMouseDownTarget = useMouseDownTarget();
  const hasDynamicHeight = computedVariant === "full-page";
  const overlapElement = useDynamicOverlap({ disabled: !hasDynamicHeight });
  use_table_focus_navigation_default({
    enableKeyboardNavigation,
    selectionType,
    tableRoot: tableRefObject,
    columnDefinitions: visibleColumnDefinitions,
    numRows: allItems === null || allItems === void 0 ? void 0 : allItems.length
  });
  const toolsHeaderWrapper = (0, import_react40.useRef)(null);
  const toolsHeaderHeight = (_f = (_e = toolsHeaderWrapper === null || toolsHeaderWrapper === void 0 ? void 0 : toolsHeaderWrapper.current) === null || _e === void 0 ? void 0 : _e.getBoundingClientRect().height) !== null && _f !== void 0 ? _f : 0;
  const colIndexOffset = selectionType ? 1 : 0;
  const totalColumnsCount = visibleColumnDefinitions.length + colIndexOffset;
  return import_react40.default.createElement(
    LinkDefaultVariantContext.Provider,
    { value: { defaultVariant: "primary" } },
    import_react40.default.createElement(
      ColumnWidthsProvider,
      { visibleColumns: visibleColumnWidthsWithSelection, resizableColumns, containerRef: wrapperMeasureRefObject },
      import_react40.default.createElement(
        InternalContainer,
        Object.assign({}, baseProps, { __internalRootRef, className: clsx_m_default(baseProps.className, styles_css_default3.root), __funnelSubStepProps, header: import_react40.default.createElement(
          import_react40.default.Fragment,
          null,
          hasHeader && import_react40.default.createElement(
            "div",
            { ref: overlapElement, className: clsx_m_default(hasDynamicHeight && [styles_css_default3["dark-header"], getContentHeaderClassName()]) },
            import_react40.default.createElement(
              "div",
              { ref: toolsHeaderWrapper, className: clsx_m_default(styles_css_default3["header-controls"], styles_css_default3[`variant-${computedVariant}`]) },
              import_react40.default.createElement(
                CollectionLabelContext.Provider,
                { value: { assignId: setHeaderRef } },
                import_react40.default.createElement(ToolsHeader, { header, filter, pagination, preferences })
              )
            )
          ),
          stickyHeader && import_react40.default.createElement(sticky_header_default, { ref: stickyHeaderRef, variant: computedVariant, theadProps, wrapperRef: wrapperRefObject, theadRef, secondaryWrapperRef, tableRef: tableRefObject, onScroll: handleScroll, tableHasHeader: hasHeader, contentDensity, tableRole })
        ), disableHeaderPaddings: true, disableContentPaddings: true, variant: toContainerVariant(computedVariant), __disableFooterPaddings: true, __disableFooterDivider: true, __disableStickyMobile: false, footer: hasFooter ? import_react40.default.createElement(
          "div",
          { className: clsx_m_default(styles_css_default3["footer-wrapper"], styles_css_default3[`variant-${computedVariant}`]) },
          import_react40.default.createElement(
            "div",
            { className: clsx_m_default(styles_css_default3.footer, hasFooterPagination && styles_css_default3["footer-with-pagination"]) },
            footer && import_react40.default.createElement("span", null, footer),
            hasFooterPagination && import_react40.default.createElement("div", { className: styles_css_default3["footer-pagination"] }, pagination)
          )
        ) : null, __stickyHeader: stickyHeader, __mobileStickyOffset: toolsHeaderHeight, __stickyOffset: stickyHeaderVerticalOffset }, focusMarkers.root),
        import_react40.default.createElement(
          "div",
          Object.assign({ ref: wrapperRef, className: clsx_m_default(styles_css_default3.wrapper, styles_css_default3[`variant-${computedVariant}`], {
            [styles_css_default3["has-footer"]]: hasFooter,
            [styles_css_default3["has-header"]]: hasHeader
          }), style: stickyState.style.wrapper, onScroll: handleScroll }, wrapperProps),
          import_react40.default.createElement("div", { className: styles_css_default3["wrapper-content-measure"], ref: wrapperMeasureMergedRef }),
          !!renderAriaLive && !!firstIndex && import_react40.default.createElement(
            live_region_default,
            null,
            import_react40.default.createElement("span", null, renderAriaLive({ totalItemsCount, firstIndex, lastIndex: firstIndex + items.length - 1 }))
          ),
          import_react40.default.createElement(
            GridNavigationProvider,
            { keyboardNavigation: !!enableKeyboardNavigation, pageSize: GRID_NAVIGATION_PAGE_SIZE, getTable: () => tableRefObject.current },
            import_react40.default.createElement(
              "table",
              Object.assign({ ref: tableRef, className: clsx_m_default(styles_css_default3.table, resizableColumns && styles_css_default3["table-layout-fixed"], contentDensity === "compact" && getVisualContextClassname("compact-table")) }, getTableRoleProps({
                tableRole,
                totalItemsCount,
                totalColumnsCount,
                ariaLabel: ariaLabels === null || ariaLabels === void 0 ? void 0 : ariaLabels.tableLabel,
                ariaLabelledBy: isLabelledByHeader && headerIdRef.current ? headerIdRef.current : void 0
              })),
              import_react40.default.createElement(thead_default, Object.assign({ ref: theadRef, hidden: stickyHeader, onFocusedComponentChange: (focusId) => {
                var _a2;
                return (_a2 = stickyHeaderRef.current) === null || _a2 === void 0 ? void 0 : _a2.setFocus(focusId);
              } }, theadProps)),
              import_react40.default.createElement("tbody", null, loading || allItems.length === 0 ? import_react40.default.createElement(
                "tr",
                null,
                import_react40.default.createElement(NoDataCell, { totalColumnsCount, hasFooter, loading, loadingText, empty, tableRef: tableRefObject, containerRef: wrapperMeasureRefObject })
              ) : allItems.map((item, rowIndex) => {
                const isFirstRow = rowIndex === 0;
                const isLastRow = rowIndex === allItems.length - 1;
                const sharedCellProps = {
                  isFirstRow,
                  isLastRow,
                  isVisualRefresh,
                  isSelected: hasSelection && isItemSelected(item),
                  isPrevSelected: hasSelection && !isFirstRow && isItemSelected(allItems[rowIndex - 1]),
                  isNextSelected: hasSelection && !isLastRow && isItemSelected(allItems[rowIndex + 1]),
                  isEvenRow: rowIndex % 2 === 0,
                  hasFooter,
                  stripedRows,
                  stickyState,
                  tableRole
                };
                const expandableItemProps = getExpandableItemProps(item);
                return import_react40.default.createElement(
                  "tr",
                  Object.assign({ key: getItemKey(trackBy, item, rowIndex), className: clsx_m_default(styles_css_default3.row, sharedCellProps.isSelected && styles_css_default3["row-selected"]), onFocus: ({ currentTarget }) => {
                    var _a2;
                    if (!currentTarget.contains(getMouseDownTarget())) {
                      (_a2 = stickyHeaderRef.current) === null || _a2 === void 0 ? void 0 : _a2.scrollToRow(currentTarget);
                    }
                  } }, focusMarkers.item, { onClick: onRowClickHandler && onRowClickHandler.bind(null, rowIndex, item), onContextMenu: onRowContextMenuHandler && onRowContextMenuHandler.bind(null, rowIndex, item) }, getTableRowRoleProps(Object.assign({ tableRole, firstIndex, rowIndex }, expandableItemProps))),
                  hasSelection && import_react40.default.createElement(
                    TableTdElement,
                    Object.assign({}, sharedCellProps, { className: clsx_m_default(styles_css_default3["selection-control"]), wrapLines: false, hasSelection: true, columnId: selectionColumnId, colIndex: 0 }),
                    import_react40.default.createElement(SelectionControl, Object.assign({ onFocusDown: moveFocusDown, onFocusUp: moveFocusUp, onShiftToggle: updateShiftToggle }, getItemSelectionProps(item)))
                  ),
                  visibleColumnDefinitions.map((column, colIndex) => {
                    var _a2;
                    const isEditing = cellEditing.checkEditing({ rowIndex, colIndex });
                    const successfulEdit = cellEditing.checkLastSuccessfulEdit({ rowIndex, colIndex });
                    const isEditable = !!column.editConfig && !cellEditing.isLoading;
                    const expandableCellProps = isExpandable && colIndex === 0 ? expandableItemProps : void 0;
                    return import_react40.default.createElement(TableBodyCell, Object.assign({ key: getColumnKey(column, colIndex) }, sharedCellProps, { style: resizableColumns ? {} : {
                      width: column.width,
                      minWidth: column.minWidth,
                      maxWidth: column.maxWidth
                    }, ariaLabels, column, item, wrapLines, isEditable, isEditing, isRowHeader: column.isRowHeader, successfulEdit, onEditStart: () => cellEditing.startEdit({ rowIndex, colIndex }), onEditEnd: (editCancelled) => cellEditing.completeEdit({ rowIndex, colIndex }, editCancelled), submitEdit: cellEditing.submitEdit, columnId: (_a2 = column.id) !== null && _a2 !== void 0 ? _a2 : colIndex, colIndex: colIndex + colIndexOffset }, expandableCellProps));
                  })
                );
              }))
            )
          ),
          resizableColumns && import_react40.default.createElement(ResizeTracker, null)
        ),
        import_react40.default.createElement(sticky_scrollbar_default, { ref: scrollbarRef, wrapperRef: wrapperRefObject, tableRef: tableRefObject, onScroll: handleScroll, hasStickyColumns })
      )
    )
  );
});
var internal_default4 = InternalTable;

// node_modules/@cloudscape-design/components/internal/analytics/components/analytics-funnel.js
var import_react41 = __toESM(require_react());
var FUNNEL_VERSION = "1.4";
var AnalyticsFunnel = (props) => {
  const { isInFunnel } = useFunnel();
  if (isInFunnel && props.funnelType === "single-page") {
    return import_react41.default.createElement(import_react41.default.Fragment, null, props.children);
  }
  return import_react41.default.createElement(InnerAnalyticsFunnel, Object.assign({}, props));
};
var CREATION_EDIT_FLOW_DONE_EVENT_NAME = "awsui-creation-edit-flow-done";
var dispatchCreateEditFlowDoneEvent = () => {
  var _a;
  try {
    (_a = window.top) === null || _a === void 0 ? void 0 : _a.document.dispatchEvent(new Event(CREATION_EDIT_FLOW_DONE_EVENT_NAME));
  } catch (_b) {
  }
};
var onFunnelCancelled = ({ funnelInteractionId }) => {
  FunnelMetrics.funnelCancelled({ funnelInteractionId });
};
var onFunnelComplete = ({ funnelInteractionId }) => {
  FunnelMetrics.funnelComplete({ funnelInteractionId });
  dispatchCreateEditFlowDoneEvent();
};
function evaluateSelectors(selectors, defaultSelector) {
  for (const selector of selectors) {
    const element = document.querySelector(selector);
    if (element) {
      return selector;
    }
  }
  return defaultSelector;
}
var InnerAnalyticsFunnel = (_a) => {
  var { children, stepConfiguration } = _a, props = __rest(_a, ["children", "stepConfiguration"]);
  const [funnelInteractionId, setFunnelInteractionId] = (0, import_react41.useState)("");
  const [submissionAttempt, setSubmissionAttempt] = (0, import_react41.useState)(0);
  const isVisualRefresh = useVisualRefresh();
  const funnelState = (0, import_react41.useRef)("default");
  const funnelNameSelector = (0, import_react41.useRef)(getFunnelNameSelector());
  const errorCount = (0, import_react41.useRef)(0);
  const loadingButtonCount = (0, import_react41.useRef)(0);
  const wizardCount = (0, import_react41.useRef)(0);
  const latestFocusCleanupFunction = (0, import_react41.useRef)(void 0);
  (0, import_react41.useEffect)(() => {
    let funnelInteractionId2;
    const handle = setTimeout(() => {
      var _a2;
      funnelNameSelector.current = evaluateSelectors(props.funnelNameSelectors || [], getFunnelNameSelector());
      if (props.funnelType === "single-page" && wizardCount.current > 0) {
        return;
      }
      funnelState.current = "default";
      const singleStepFlowStepConfiguration = [
        { number: 1, isOptional: false, name: (_a2 = getNameFromSelector(funnelNameSelector.current)) !== null && _a2 !== void 0 ? _a2 : "" }
      ];
      funnelInteractionId2 = FunnelMetrics.funnelStart({
        instanceIdentifier: props.instanceIdentifier,
        flowType: props.flowType,
        funnelNameSelector: funnelNameSelector.current,
        optionalStepNumbers: props.optionalStepNumbers,
        funnelType: props.funnelType,
        totalFunnelSteps: props.totalFunnelSteps,
        componentVersion: PACKAGE_VERSION,
        theme: isVisualRefresh ? "vr" : "classic",
        funnelVersion: FUNNEL_VERSION,
        stepConfiguration: stepConfiguration !== null && stepConfiguration !== void 0 ? stepConfiguration : singleStepFlowStepConfiguration
      });
      setFunnelInteractionId(funnelInteractionId2);
    }, 1);
    return () => {
      clearTimeout(handle);
      if (props.funnelType === "single-page" && wizardCount.current > 0) {
        return;
      }
      if (funnelState.current === "validating") {
        onFunnelComplete({ funnelInteractionId: funnelInteractionId2 });
        funnelState.current = "complete";
      }
      if (funnelState.current === "complete") {
        FunnelMetrics.funnelSuccessful({ funnelInteractionId: funnelInteractionId2 });
      } else {
        onFunnelCancelled({ funnelInteractionId: funnelInteractionId2 });
        funnelState.current = "cancelled";
      }
    };
  }, []);
  const funnelSubmit = () => {
    funnelState.current = "validating";
    const VALIDATION_WAIT_DELAY = 50;
    const LOADING_WAIT_DELAY = 100;
    const checkForCompleteness = () => {
      if (funnelState.current === "complete") {
        return;
      }
      if (loadingButtonCount.current > 0) {
        setTimeout(checkForCompleteness, LOADING_WAIT_DELAY);
        return;
      }
      if (errorCount.current === 0) {
        onFunnelComplete({ funnelInteractionId });
        funnelState.current = "complete";
      } else {
        funnelState.current = "default";
      }
    };
    setTimeout(checkForCompleteness, VALIDATION_WAIT_DELAY);
  };
  const funnelNextOrSubmitAttempt = () => setSubmissionAttempt((i) => i + 1);
  const funnelCancel = () => {
  };
  const funnelContextValue = {
    funnelInteractionId,
    setFunnelInteractionId,
    funnelType: props.funnelType,
    optionalStepNumbers: props.optionalStepNumbers,
    totalFunnelSteps: props.totalFunnelSteps,
    funnelNameSelector: funnelNameSelector.current,
    funnelSubmit,
    funnelCancel,
    submissionAttempt,
    funnelNextOrSubmitAttempt,
    funnelState,
    errorCount,
    loadingButtonCount,
    latestFocusCleanupFunction,
    isInFunnel: true,
    wizardCount
  };
  return import_react41.default.createElement(FunnelContext.Provider, { value: funnelContextValue }, children);
};
var AnalyticsFunnelStep = (props) => {
  return import_react41.default.createElement(InnerAnalyticsFunnelStep, Object.assign({}, props, { key: props.stepNumber }));
};
function getSubStepConfiguration() {
  const subSteps = Array.from(document.querySelectorAll(getSubStepAllSelector()));
  const subStepConfiguration = subSteps.map((substep, index) => {
    var _a, _b, _c;
    const name = (_c = (_b = (_a = substep.querySelector(getSubStepNameSelector())) === null || _a === void 0 ? void 0 : _a.innerText) === null || _b === void 0 ? void 0 : _b.trim()) !== null && _c !== void 0 ? _c : "";
    return {
      name,
      number: index + 1
    };
  });
  return subStepConfiguration;
}
function useStepChangeListener(stepNumber, handler) {
  const subStepConfiguration = (0, import_react41.useRef)(/* @__PURE__ */ new Map());
  const SUBSTEP_CHANGE_DEBOUNCE = 50;
  const listenForSubStepChanges = (0, import_react41.useRef)(false);
  (0, import_react41.useEffect)(() => {
    const handle = setTimeout(() => listenForSubStepChanges.current = true, SUBSTEP_CHANGE_DEBOUNCE);
    return () => {
      clearTimeout(handle);
      listenForSubStepChanges.current = false;
    };
  }, []);
  (0, import_react41.useEffect)(() => {
    const handle = setTimeout(() => subStepConfiguration.current.set(stepNumber, getSubStepConfiguration()), SUBSTEP_CHANGE_DEBOUNCE);
    return () => {
      clearTimeout(handle);
    };
  }, [stepNumber]);
  const stepChangeCallback = useDebounceCallback(() => {
    if (!listenForSubStepChanges.current) {
      return;
    }
    subStepConfiguration.current.set(stepNumber, getSubStepConfiguration());
    handler(subStepConfiguration.current.get(stepNumber));
  }, SUBSTEP_CHANGE_DEBOUNCE);
  return { onStepChange: stepChangeCallback, subStepConfiguration };
}
var InnerAnalyticsFunnelStep = (_a) => {
  var { children, stepNumber, instanceIdentifier } = _a, rest = __rest(_a, ["children", "stepNumber", "instanceIdentifier"]);
  const { funnelInteractionId, funnelNameSelector, funnelState, funnelType } = useFunnel();
  const parentStep = useFunnelStep();
  const parentStepExists = parentStep.isInStep;
  const parentStepFunnelInteractionId = parentStep.funnelInteractionId;
  const funnelStepProps = { [DATA_ATTR_FUNNEL_STEP]: stepNumber };
  const subStepCount = (0, import_react41.useRef)(0);
  const stepNameSelector = rest.stepNameSelector || funnelNameSelector;
  const { onStepChange, subStepConfiguration } = useStepChangeListener(stepNumber, (subStepConfiguration2) => {
    var _a2;
    if (!funnelInteractionId) {
      return;
    }
    const stepName = (_a2 = getNameFromSelector(stepNameSelector)) !== null && _a2 !== void 0 ? _a2 : "";
    FunnelMetrics.funnelStepChange({
      instanceIdentifier,
      funnelInteractionId,
      stepNumber,
      stepName,
      stepNameSelector,
      subStepAllSelector: getSubStepAllSelector(),
      totalSubSteps: subStepCount.current,
      subStepConfiguration: subStepConfiguration2
    });
  });
  (0, import_react41.useEffect)(() => {
    if (!funnelInteractionId) {
      return;
    }
    if (parentStepExists && parentStepFunnelInteractionId) {
      return;
    }
    const stepName = getNameFromSelector(stepNameSelector);
    if (funnelState.current === "default") {
      FunnelMetrics.funnelStepStart({
        instanceIdentifier,
        funnelInteractionId,
        stepNumber,
        stepName,
        stepNameSelector,
        subStepAllSelector: getSubStepAllSelector(),
        totalSubSteps: subStepCount.current,
        subStepConfiguration: getSubStepConfiguration()
      });
    }
    return () => {
      if (funnelState.current !== "cancelled") {
        FunnelMetrics.funnelStepComplete({
          instanceIdentifier,
          funnelInteractionId,
          stepNumber,
          stepName,
          stepNameSelector,
          subStepAllSelector: getSubStepAllSelector(),
          // eslint-disable-next-line react-hooks/exhaustive-deps
          totalSubSteps: subStepCount.current
        });
      }
    };
  }, [
    instanceIdentifier,
    funnelInteractionId,
    stepNumber,
    stepNameSelector,
    funnelState,
    parentStepExists,
    funnelType,
    parentStepFunnelInteractionId
  ]);
  const contextValue = {
    instanceIdentifier,
    stepNumber,
    stepNameSelector,
    funnelStepProps,
    subStepCount,
    isInStep: true,
    funnelInteractionId,
    onStepChange,
    subStepConfiguration
  };
  const effectiveContextValue = parentStepExists && parentStepFunnelInteractionId ? parentStep : contextValue;
  return import_react41.default.createElement(FunnelStepContext.Provider, { value: effectiveContextValue }, typeof children === "function" ? children(effectiveContextValue) : children);
};
var AnalyticsFunnelSubStep = ({ children, instanceIdentifier }) => {
  const subStepId = useUniqueId("substep");
  const subStepSelector = getSubStepSelector(subStepId);
  const subStepNameSelector = getSubStepNameSelector(subStepId);
  const subStepRef = (0, import_react41.useRef)(null);
  const { subStepCount, onStepChange } = useFunnelStep();
  const mousePressed = (0, import_react41.useRef)(false);
  const isFocusedSubStep = (0, import_react41.useRef)(false);
  const focusCleanupFunction = (0, import_react41.useRef)(void 0);
  const { funnelState, funnelInteractionId } = useFunnel();
  const { stepNumber, stepNameSelector } = useFunnelStep();
  const newContext = {
    instanceIdentifier,
    subStepSelector,
    subStepNameSelector,
    subStepId,
    subStepRef,
    mousePressed,
    isFocusedSubStep,
    focusCleanupFunction,
    isNestedSubStep: false
  };
  const inheritedContext = Object.assign(Object.assign({}, (0, import_react41.useContext)(FunnelSubStepContext)), { isNestedSubStep: true });
  const isNested = Boolean(inheritedContext.subStepId);
  (0, import_react41.useEffect)(() => {
    if (!isNested) {
      subStepCount.current++;
      onStepChange();
      return () => {
        subStepCount.current--;
        onStepChange();
      };
    }
  }, [isNested, subStepCount, onStepChange]);
  const context = isNested ? inheritedContext : newContext;
  (0, import_react41.useEffect)(() => {
    if (isNested || !subStepRef.current) {
      return;
    }
    const onMouseDown = () => mousePressed.current = true;
    const onMouseUp = () => __awaiter(void 0, void 0, void 0, function* () {
      var _a;
      mousePressed.current = false;
      if (!isFocusedSubStep.current) {
        return;
      }
      yield new Promise((r) => setTimeout(r, 1));
      if (!subStepRef.current || !document.activeElement || !nodeBelongs(subStepRef.current, document.activeElement)) {
        isFocusedSubStep.current = false;
        (_a = focusCleanupFunction.current) === null || _a === void 0 ? void 0 : _a.call(focusCleanupFunction);
      }
    });
    window.addEventListener("mousedown", onMouseDown);
    window.addEventListener("mouseup", onMouseUp);
    return () => {
      window.removeEventListener("mousedown", onMouseDown);
      window.removeEventListener("mouseup", onMouseUp);
    };
  }, [
    funnelInteractionId,
    funnelState,
    stepNameSelector,
    stepNumber,
    subStepNameSelector,
    subStepSelector,
    focusCleanupFunction,
    isNested,
    subStepRef
  ]);
  return import_react41.default.createElement(FunnelSubStepContext.Provider, { value: context }, typeof children === "function" ? children(context) : children);
};

// node_modules/@cloudscape-design/components/table/index.js
var Table = import_react42.default.forwardRef((_a, ref) => {
  var { items = [], selectedItems = [], variant = "container", contentDensity = "comfortable" } = _a, props = __rest(_a, ["items", "selectedItems", "variant", "contentDensity"]);
  const baseComponentProps = useBaseComponent("Table", {
    props: {
      contentDensity,
      resizableColumns: props.resizableColumns,
      selectionType: props.selectionType,
      stickyHeader: props.stickyHeader,
      stripedRows: props.stripedRows,
      variant,
      wrapLines: props.wrapLines,
      enableKeyboardNavigation: props.enableKeyboardNavigation
    },
    metadata: {
      expandableRows: !!props.expandableRows
    }
  });
  const tableProps = Object.assign(Object.assign(Object.assign({
    items,
    selectedItems,
    variant,
    contentDensity
  }, props), baseComponentProps), { ref });
  if (variant === "borderless" || variant === "embedded") {
    return import_react42.default.createElement(internal_default4, Object.assign({}, tableProps));
  }
  return import_react42.default.createElement(
    AnalyticsFunnelSubStep,
    null,
    import_react42.default.createElement(InternalTableAsSubstep, Object.assign({}, tableProps))
  );
});
applyDisplayName(Table, "Table");
var table_default = Table;

export {
  getVisualContextClassname,
  VisualContext,
  styles_css_default9 as styles_css_default,
  isRtl,
  getScrollInlineStart,
  getLogicalBoundingClientRect,
  PopoverContainer,
  PopoverBody,
  getGlobalFlag,
  usePortalModeClasses,
  arrow_default,
  useHiddenDescription,
  DynamicOverlapContext,
  shouldRemoveHighContrastHeader,
  getContentHeaderClassName,
  StatusIndicator,
  usePrevious,
  AsyncStore,
  useReaction,
  useSelector,
  useDynamicOverlap,
  InternalContainerAsSubstep,
  InternalContainer,
  AnalyticsFunnel,
  AnalyticsFunnelStep,
  AnalyticsFunnelSubStep,
  ToolsHeader,
  getItemKey,
  SelectionControl,
  focusMarkers,
  useSelectionFocusMove,
  useSelection,
  stickyScrolling,
  useMouseDownTarget,
  internal_default4 as internal_default,
  table_default
};
//# sourceMappingURL=chunk-EKTGMWG5.js.map
